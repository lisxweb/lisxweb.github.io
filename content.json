[{"title":"整理MAC下Eclipse的常用快捷键","date":"2016-11-21T05:58:09.000Z","path":"2016/11/21/整理MAC下Eclipse的常用快捷键/","content":"整理Eclipse常用快捷键开发环境切换到Mac下后原来Window下的快捷键很大一部分是不相容的，习惯了快捷键的生活忽然哪天快捷键不起作用了，跟着的就是开发效率明显降低，频繁录入错误的快捷键让Eclipse都不知道你想要什么了。 以下内容是我整理的经常使用的Eclipse快捷键，主要依据首个按键进行了分类。文档末尾是收集了Mac系统下对文本编辑当标跳转或选中的快捷键。 一、|Command类|Command+1|快速修复||Command+d|删除当前行||Command+Option+↓|复制当前行到下一行||Command+Option+↑|复制当前行到上一行||Command+←|移动光标至当前行的行首||Command+→移动光标至当前行的行尾|Command+t快速显示当前类的结构|Command+w关闭当前编辑页|Command+Option+←前一个编辑的页面|Command+Option+→后一个编辑的页面|Command+k参考当前编辑页选中的关键字向下搜索|Command+e显示当前编辑页面列表可选择页面进行切换|Command+/注释或反注释当前行|Command+Shift+e显示Editor管理器，可选择切换editor|Command+j正向查找，在当前编辑页中查找录入的字符，注意Eclipse状态栏的提示|Command+Shift+J反向查找，使用方式与正向查找类似|Command+Shift+W关闭所有打开的Editor|Command+Shift+P定位匹配符，适用于代码规模比较大的场景，如在while(){}循环体的末尾}处，想要跳转到while(){处。|Command+[向后导航到上一个编辑的文件|Command+]向前导航到下一个编辑的文件 二、Option类Option+↓向下移动当前行Option+↑向上移动当前行Option+回车显示当前选择资源的属性Option+/代码助手“智能提示”Option+|Command+R重命名Option+|Command+C修改函数结构，适用重构Option+|Command+L抽取本地变量 三、Control类Control+M最大化或还原当前editor或view 四、Shift类Shift+|Command+↑选中光标至全部文本的开头Shift+|Command+↓选中光标至全部文本的结尾Shift+|Command+→选中光标至当前行的结尾Shift+|Command+←选中光标至当前行的开头 五、补充说明Eclipse对于文本编辑跳转和选中跳转这块基本和Mac系统一致是通用的，以下内容是Mac系统对文本选中或中或跳转这块的支持。1.文本位置跳转快捷键：跳转到一行的开头：|Command+左箭头跳转到一行的末尾：|Command+右箭头跳转到当前单词的开头(适合英文、拼音)：Option+左箭头跳转到当前单词的末尾(适合英文、拼音)：Option+右箭头跳转到全部文本的开头：|Command+上箭头跳转到全部文本的末尾：|Command+下箭头2.文本选中快捷键在以上快捷键中加入Shift，则可以扩展成为选中文本效果的快捷键 选中光标到本行开头的文本：Shift+|Command+左箭头选中光标到本行末尾的文本：Shift+|Command+右箭头选中光标到当前单词的开头(适合英文、拼音)：Shift+Option+左箭头选中光标到当前单词的末尾(适合英文、拼音)：Shift+Option+右箭头选中光标到全部文本的开头：Shift+|Command+上箭头选中光标到全部文本的末尾：Shift+|Command+下箭头3.vim中一些快捷键Shift+4行尾Shift+6行首Shift+G文档末尾gg文档头六、Terminal光标相关Ctrl+u删除光标到行首的字符Ctrl+k删除光标到行尾的字符Ctrl+h删除一个字符(退格删除)Ctrl+c取消当前行输入的命令Ctrl+a光标移到行首Ctrl+e光标移动行尾Ctrl+l清屏（与clear类似）Ctrl+p调出命令历史中上一条(与↑类似)Ctrl+n调出命令历史中下一条(与↓类似)Ctrl+w删除当前光标前的一个单词Ctrl+y粘贴(Ctrl+w)删除的单词Alt+←单词间移动向左Alt+→单词间移动向右","tags":[{"name":"MAC Eclipse 快捷键","slug":"MAC-Eclipse-快捷键","permalink":"http://lisxweb.github.io/tags/MAC-Eclipse-快捷键/"}]},{"title":"Linux服务器增量备份脚本","date":"2016-11-21T05:54:02.000Z","path":"2016/11/21/Linux服务器增量备份脚步/","content":"本地脚步： #!/bin/bashdateTime=date +%Y-%m-%drmTime=date +%Y-%m-%d &#39;-d -1 day&#39;localPath=/demoremotePath=/demoremoteName=229bakList=/bak/$dateTime.listbakLog=/bak/$dateTime.logbakData=/bak/$dateTime.tar.gzrmFile=/bak/$rmTime.*echo “进入备份目录”cd $localPathecho “获取今天要备份的文件到list”ls -l –time-style=”+%Y-%m-%d” | grep $dateTime|awk ‘{ print $7 }’&gt;$bakListecho “压缩要备份的文件”tar -zcvf $bakData -T $bakListecho “将压缩文件上传到服务器”script -a $bakLog -q -c “scp $bakData $remoteName:$remotePath”script -a $bakLog -q -c “scp $bakList $remoteName:$remotePath”scp $bakLog $remoteName:$remotePathecho “删除昨天本地的压缩备份文件”rm -rf $rmFile 远程脚步：每天解压昨天转过来的文件 #!/bin/bashecho “获取昨天日期”dateTime=date +%Y-%m-%d &#39;-d -1 day&#39;localPath=/demobakData=$dateTime.tar.gzecho “进入备份目录”cd $localPathecho “获取昨天备份的文件解压”tar -zxvf $bakData","tags":[{"name":"Linux服务器","slug":"Linux服务器","permalink":"http://lisxweb.github.io/tags/Linux服务器/"}]},{"title":"第二章 基础概念","date":"2016-11-18T08:00:12.000Z","path":"2016/11/18/第二章-基础概念/","content":"第二章 基础概念2.1 MVC模型 Play应用遵循了MVC模式并将其运用到Web架构中。该模式将应用分为不同的层:表现层和模型层，其中表现层又可以分为视图层和控制层。 模型层是对数据的特定域呈现，域逻辑对原生的数据增加了含义（比如：计算今天是不是用户的生日，或者为购物车计算总价、税费、运费等）。大部分应用使用持久化存储机制（比如数据库）来保存数据。MVC并没有特别关注数据访问层，因为这被认为是底层的工作或者仅仅通过Model进一步封装而已。 视图层将模型渲染成有利于交互的形式（通常称之为用户界面UI），单个模型能够存在于多个视图，以此满足不同的需求。在Web应用中，视图通常使用Web格式来呈现信息，如HTML、XML、JSON等。但是还有一些用例中使用二进制的形式来表现，比如需要动态渲染图表。 控制层用来响应和处理事件（通常是用户的行为），并且可以通过方法调用对模型作出变更。在Web应用中，事件一般为HTTP请求。控制器会监听HTTP请求，从请求中获取相关的数据(例如查询字符串参数、请求报头等)，查询并返回数据或者直接改变底层模型对象。 图片资源/diagrams_mvc.png(图2.1 MVC模式) Play应用中的这些层都定义在app目录中，每个层都处于独立的包中。 app/controllers: 控制器是Java类，包含了被声明为public static的Action方法。Action是当接收HTTP请求后被调用的Java入口，控制器类中的Java代码事实上不是面向对象的，而是面向过程的。Action方法从HTTP请求中获取相关数据，读取或者更新模型对象，并且返回封装成HTTP响应的结果。 app/models: 域模型对象层是受用于Java语言面向对象特性的一组Java类，包含了数据结构和应用对数据的相关操作。当模型对象需要持久化存储时，可能还会包含一些JPA注解或者SQL语句。 app/views: 大部分视图都使用Play提供的高效模板引擎生成，控制器从模型层得到想要的数据，然后应用模板修饰这些对象。该目录下通常包含HTML、XML、JSON等模板文件，通过模板引擎动态渲染模型。 Play是一个完全无状态的，只面向请求/响应的框架，所有HTTP请求都具有相同的处理流程： 2.2 生命周期框架接收HTTP请求。路由组件找到最匹配的规则，接受并处理请求，随后调用相应的Action方法。执行Action中的应用代码。如果需要生成复杂的视图，使用模板文件进行渲染。Action方法的返回结果（HTTP响应代码以及内容）被转换为HTTP响应。 图2.2示意了HTTP请求处理的周期（Play应用的生命周期）： 图片资源/diagrams_path.png;(图2.2 Play生命周期) Play为应用层制定了标准，使目录结构尽可能地保持一致。 2.3 应用层次结构2.3.1 app目录 该目录下包含了所有可执行组件：Java源文件和视图模板。 提示：读者可能会问.class文件在哪里？不用寻找编译后的Java文件，因为框架在运行时编译Java源文件并将编译后的.class文件以字节码缓存的形式保存在tmp目录下。从开发的角度讲，Play应用中主要的可执行组件为.java源文件，而不是编译后的.class文件。 在app目录中有三个标准的包，每个包对应MVC模式中的一层，当然也可以增加自己的包（比如utils包）。其中视图包（views）可以进一步划分成多个子包： 按照模板约束规则，每个视图文件夹对应一个控制器，保存相对应的模板文件。划分tags包，用于存放应用模板标签，比如可重用的模板片段等。 2.3.2 public 目录 保存在public目录中的都是静态资源，直接为Web服务所用（不需要服务器端做任何处理，直接将资源返回给客户端）。该目录拆分为三个标准子目录：images，javascripts和stylesheets 。开发当中应该尝试以这种方式组织静态资源，以便保持所有Play应用的一致性。 提示：默认情况下public目录被映射为/public的URL路径，通过配置conf/routes文件可以改变路由规则。当然，也可以在该目录下使用更多的文件夹来存放静态资源为Web服务所用。 2.3.3 conf目录 该目录包含了与应用有关的所有配置文件，以下两个配置文件是必须的： application.conf：应用的主配置文件，内含标准的配置选项。routes：应用的路由配置文件，用于定义路由规则。 提示：如果某个特定的应用需要增加一些额外的配置选项，可以将这些配置添加到application.conf文件中。应用程序代码中则可以通过Play.configuration.get(“propertyName”)方法读取对应的配置信息。如果一些类库需要独立的配置文件，可以将此文件放到conf目录下，该目录下的文件会被自动加载到应用的Java classpath中。 当为应用增加额外配置文件时，需要对application.conf文件进行一些配置。使用@include标签可以将额外配置文件包含进来，比如在应用的conf目录下添加配置文件mime-types.conf，为应用定义额外的MIME类型： # Web fontsmimetype.eot = application/vnd.ms-fontobjectmimetype.otf = application/octet-streammimetype.ttf = application/octet-streammimetype.woff = application/x-font-woff 在application.conf文件中需要添加如下行来包含上述的配置文件： @include.mime = mime-types.conf 2.3.4 lib目录 该目录包含了应用所需的标准Java类库，通常为Play内置类库以外的jar包（由于Play自身内置了大部分常用的第三方类库，比如Hibernate，Log4j，Gson,Groovy等，因此只需要将开发过程中Play没有提供的jar包导入即可）。这些类库会被自动添加至Java classpath中。 2.4 开发周期2.4.1 DEV和PROD模式 使用Play开发应用不存在编译、打包、部署阶段，而且Play自身实现了两种不同的环境：开发阶段的DEV模式，应用发布的PROD模式。 补充：应用可以在DEV或者PROD模式下运行，通过使用主配置文件中的application.mode属性来切换运行环境。当应用运行在DEV模式下时，Play会检查文件的变更并在有需要的时候进行热加载。而PROD模式对产品做了充分优化，Java源代码和模板文件只会在应用开启的时候被编译，之后以缓存的形式响应用户请求。 在DEV模式下，如果源文件在应用运行期间被修改，源代码会重新编译并热加载到JVM。如果编译出错，浏览器中会显示出错原因以及准确的出错位置。同样地，模板文件也支持热编译和热加载。如图2.3所示。 图片资源/exact-problem.png;(图2.3 浏览器中显示出错信息) 2.4.2 连接Java调试器 应用运行在DEV模式下时，可以通过8000端口连接Java调试器。下面以Netbeans为例，介绍如何连接Java调试器： 图片资源/socket.png;(图2.4 开启8000端口) 应用在DEV模式下启动后，框架会自动开启8000端口。打开Netbeans，选择调试 &gt;&gt; 连接调试器。 图片资源/netbeans-debugger1.png;(图2.5 连接调试器步骤一) 在弹出的调试器配置中，填写相应的配置信息，点击确定按钮完成连接配置。 图片资源/netbeans-debugger2.png;(图2.6 连接调试器步骤二) 2.5 类增强类增强，也叫字节码增强，用于在运行时动态修改字节码，以便增加额外的方法、字段以及方法体内容等。Play中很多插件都包含用于在运行时更改应用实现类的增强器，比如为控制器类增加额外的方法。这便是Play不可思议的地方，也是非常核心的概念，掌握底层实现不可或缺的知识。 内置的play.CorePlugin使用play.classloading.enhancers包提供的类增强器，为应用实现类动态增加代码，主要有以下几种： ContinuationEnhancer为控制器类增加continuations支持。ControllersEnhancer为控制器中的action方法增加线程安全功能，并为方法调用提供HTTP重定向支持。LocalvariablesNamesEnhancer用于跟踪控制器中的本地变量MailerEnhancer构建play.mvc.Mailer子类PropertiesEnhancer将所有应用类都装入有效的JavaBean，所有应用类相关的属性都注入到JavaBean字段中。SigEnhancer为每个类的签名生成唯一的hash值，从而实现自动重载。 除此以外，play.db.jpa.JPAPlugin动态增强play.db.jpa.JPABase的子类，实现更为方便的JPA查询方法。这些通常都会应用到继承于play.db.jpa.Model的实体类中。上面提到的JPA查询方法都定义在play.db.jpa.GenericModel类中。 如果需要自定义类增强器，只需要在插件的enhance(ApplicationClass)方法中使用play.classloading.enhancers.Enhancer类即可。 Play底层使用Javassist库来实现类增强，下面举一个例子来说明如何在运行时动态为class增加其它功能：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example; public class TestClazz &#123; public void testMethod()&#123; //do noting; &#125; &#125;package com.example; import java.lang.reflect.Method;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import javassist.Modifier; public class MyTest &#123; public static void main(String[] args) &#123; try &#123; CtClass ctClass=ClassPool.getDefault().get(\"com.example.TestClazz\"); CtMethod testMethod=ctClass.getDeclaredMethod(\"testMethod\"); testMethod.setBody(\"&#123; System.out.println(\\\"Test Method\\\"); &#125;\"); CtMethod newMethod=new CtMethod(CtClass.voidType,\"sayHello\",new CtClass[]&#123;&#125;,ctClass); newMethod.setModifiers(Modifier.PUBLIC); StringBuffer body=new StringBuffer(); body.append(\"&#123;\\n System.out.println(\\\"hello\\\");\"); body.append(\"\\n return ;\"); body.append(\"\\n&#125;\"); newMethod.setBody(body.toString()); ctClass.addMethod(newMethod); ctClass.writeFile(\"bin\"); TestClazz testClazz=new TestClazz(); testClazz.testMethod(); Method method=testClazz.getClass().getMethod(\"sayHello\", new Class[]&#123;&#125;); method.invoke(testClazz, new Object[]&#123;&#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; Mytest类对TestClazz做了增强，在原有的testMethod中添加方法体，并增加了新的方法sayHello。 2.6 本章小结 本章重点介绍了框架的基础概念。MVC是Web应用开发当中很重要的层次化开发思想，Play通过清晰、直观的目录结构来遵循当前主流的开发方式。框架自动生成的配置文件(conf)，静态资源文件(public)，库文件(lib)，测试文件(test)等为开发者提供了很好的文件组织方式，使得所有Play工程项目具有标准、统一的应用结构。 本章同时还介绍了Play应用的生命周期，区别于传统的Java框架，Play是完全无状态的，并且采用了路由机制。Play实现了两种不同的开发环境，在DEV模式下将精力集中在业务需求的实现，大大提高了开发效率；在PROD模式下，讲究应用的性能，重点关注应用的产品化特性。","tags":[{"name":"play","slug":"play","permalink":"http://lisxweb.github.io/tags/play/"}]},{"title":"第一章 绪论","date":"2016-11-17T09:50:03.000Z","path":"2016/11/17/第一章-绪论/","content":"第一章 绪论1.1框架概述Play框架颠覆了臃肿的企业级Java EE规范，以Restful为目标并专注于开发效率，是Java敏捷开发的最佳参考方案。开发者只要具备Java以及数据库的相关基础知识就可以轻松上手，从而让Web应用开发变得更加容易，提高项目催化速度。 作为Full Stack的Java Web应用框架，Play包括了所有开发中涉及的领域：NIO应用容器，无状态MVC模型，Hibernate数据持久化，Groovy模板引擎，以及建立Web应用所需要的各种工具类。需要注意的是，这里虽然使用了Groovy，但只是将其作为页面模板语言，和Freemaker、Velocity使用自己定义的语言是同样的道理。Groovy的成熟以及它和Java的相似性决定了采用Groovy远远好于定义自己的模板语言。 Play的发展历程： 2009年10月19日发布Play 1.0稳定版，引入Groovy作为模板引擎，Python提供跨平台的Shell支持，并提供异步I/O功能。后续针对1.0进行BUG修复，以及新特性的增加：HTM5支持，提供Eclipse插件，模块仓库，App云服务等。2010年9月1日发布Play1.1稳定版本，将HTTP服务器从原来的Apache Mina替换为Jboss Netty，框架开始支持Scala语言，新的缓存特性，Oauth支持等。2011年4月13日发布Play 1.2稳定版本，将内存数据库从原来的HSQLDB转向H2，提供依赖管理，更好的异步特性等。当前最稳定版本为Play 1.2.7，于2013年8月29日发布，可以使用Java7来编写应用。当前最新版本为Play 1.3.0 RC版，于2014年6月26日发布，相信不久后就会有正式版本发布。由于设计的考量，Play已经不采用Servlet/JSP，因而早期Play 0.x版本在发展历程中不做详细介绍。 1.2框架特性 1.2.1 无缝集成现有开发环境Play1.x是基于Java的Web开发框架，允许开发者使用自己常用的集成开发工具（如Eclipse）和类库。如果读者已经以Java作为开发方向，那么无须进行开发语言、IDE或者类库的切换，要做的就是在更加高效的Java环境中开发Web应用。 1.2.2 热重载和修改BugJava在过去因为开发效率低下而臭名昭著，主要是因为其重复和乏味的编译-打包-部署周期。因此在设计框架的时候对这些因素都进行了重新考量，目标是让Play应用的开发过程变得更加高效。 Play框架会自动编译Java源文件，而不用重新启动Web服务器将代码热加载至JVM。这样做的好处是：当代码修改完保存后，框架自动编译并重载修改后的类，只需刷新浏览器就可以查看更改的结果，就像在LAMP或者Rails环境中开发一样。另外一个好处是：开发的时候甚至可以只用简单的文本编辑器，而不使用功能完备的Java IDE进行开发，如图1.1所示： (图1.1 简单的文本编辑器) 使用Play开发应用的过程中，在任何时候出现的语法错误或者异常，框架都能够准确将其定位并显示对应的提示信息。好处显而易见：应用的Bug能够很直观地显示出来，帮助开发者迅速锁定出错位置。如图1.2所示： (图1.2 框架准确定位错误代码位置) Play框架替换了原有以栈跟踪的方式来提示错误，取而代之的是在浏览器中以更加友好并且直观的页面形式来显示错误出现的确切位置(当然在控制台中仍以栈跟踪的方式显示错误信息)。此外，Play还把模板执行发生的异常信息完美地集成到了Java栈跟踪里面，如图1.3所示： (图1.3 模板执行出错后的Java堆栈跟踪) 1.2.3 简单的无状态MVC架构一端是数据库，另一端是Web浏览器，为什么我们需要在这两者之间保存状态？ 有状态并且基于组件的Java Web框架能够更加容易地保存页面状态，但这同样带来了很多其他的问题：如果用户在新的浏览器窗口中重新打开应用会发生什么？用户按了后退按钮又会是什么结果？ 无共享架构是很多Web应用框架所提倡的（ROR，Django等）。由于浏览器变得越来越强大，我们并不需要技巧性地构建HTTP模型来创建伪造的状态，只需在客户端使用Ajax或者离线存储技术就可以很容易地解决状态问题。无共享架构的另一优势是使页面的呈现更加平滑，更容易地实现局部页面更新（或者渐进式的页面处理流程）。 1.2.4 HTTP到代码的映射如果读者使用过其他的Java Web框架（比如说Struts）可能会发现，这些框架的底层实现其实是对HTTP协议做了进一步封装，所以它们提供的Java API和自身的理念会让人觉得很不自然。Play框架在设计过程中换了一种思维方式，即Web应用框架也应该提供完整、直接的方式去访问HTTP————这也是Play框架和其他Java Web框架最根本的差异。 HTTP，Request/Response模式，Rest架构风格，HTTP内容协商（Content–type negotiation），URI等等，所有这些都是Play框架的主要概念。如果用户需要将URI绑定到指定的Java方法调用，只需要在路由文件中以如下方式进行配置：1GET /clients/&#123;id&#125;&gt; Clients.show 如果Ajax，REST以及管理页面之间的“前进/后退”操作是日常开发中需要频繁考虑的需求，那么Play框架无疑是最佳的选择，因为针对这些问题它都提供了非常优秀的解决方案。 1.2.5 高效的模板引擎也许读者已经深深地感受到了JSP和表达式语言背后的理念，但是为什么在创建标签库的时候需要如此多的配置文件？为什么不能直接访问底层的模型对象？JSP中太多的限制确实让开发者感到失望，受JSP启发又不被其约束，Play框架提供了自定义的模板引擎机制。 开发者再也不需要编写这些令人厌倦的代码了：1234567891011&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\" %&gt; &lt;c:choose&gt; &lt;c:when test=\"$&#123;emails.unread != null &amp;&amp; fn:size(emails.unread)&#125;\"&gt;&gt; You have $&#123;fn:size(emails.unread)&#125; unread email(s)! &lt;/c:when&gt; &lt;c:otherwise&gt;&gt; You have no unread emails! &lt;/c:otherwise&gt;&lt;/c:choose&gt; 相信开发者更倾向于用以下方式来书写模板代码： You have ${emails.unread ?: ‘no’} ${emails.unread?.pluralize(‘email’)} ! Play模板引擎使用的表达式语言为Groovy，它提供了与Java一致的语法。Play主要使用模板机制来渲染HTML，当然也可以生成其他的文档格式，比如e-mail messages，JSON等等。 1.2.6 内置JPA支持JPA（Java Persistence API）是Java中最简洁的对象关系映射（object-relational mapping即ORM）API。如果读者以前了解或者使用过JPA，就会发现与其他框架相比，在Play中使用会更加方便。这是因为Play框架对其做了进一步封装，不需要任何配置，Play会自动开启JPA实体管理器（EM），一旦代码被调用就自动进行持久化操作。 此外，实体如果继承Play提供的play.db.jpa.Model类，操作代码将会更加简洁，更加美观：12345678public static void messages(int page) &#123; User connectedUser = User.find(\"byEmail\", connected()).first(); List&lt;Message&gt; messages = Message.find(&gt; \"user = ? and read = false order by date desc\",&gt; connectedUser ).from(page * 10).fetch(10); render(connectedUser, messages);&#125; 1.2.7 测试驱动开发（TDD）框架集成的测试运行器（Test Runner）让测试驱动开发变的非常简单。Play允许开发者编写各种类型的测试，从基本的单元测试到完善的验收测试，以及直接在浏览器中运行的Selenium测试。值得注意的是，这些测试还可以进行代码覆盖率的统计，具体的测试界面如图1.4所示。 (图1.4 浏览器中的测试运行器) 1.2.8 Full Stack应用框架Play框架的最初设计受到实际Java Web开发的启发，包含了所有创建主流Web应用所需要的工具： 通过JDBC提供关系数据库支持。使用Hibernate进行对象关系映射（JPA）。使用分布式Memcached集成缓存支持。以JSON或者XML的形式提供web service支持。基于OpenID的分布式用户信息验证。Web应用可以部署在任何应用服务器上（Tomcat，Jboss，GAE，Cloud等）。图像处理API（验证码）。 此外Play还提供了很多实用的模块。开发者可以结合这些模块构建Web应用，这使得我们可以以更加简单，更加直接的方式重用Java代码、模板以及静态资源（比如JavaScript和CSS文件）。 1.2.9 Play的特性总结 自动编译和重载：当编辑Java文件并保存后，刷新浏览器就能立即查看结果。使用Play开发不需要手动编译、部署以及重新启动Web服务器等操作。无状态模型：Play是真正的无共享框架，为REST而准备。它可以将同一个应用的多个实例分别部署在多台服务器上，因而扩展性非常强。高效的模板引擎：基于表达式语言Groovy的清晰模板引擎，提供了模板的继承、导入以及标签自定义等功能。快速解决错误：当错误发生时，Play会在浏览器中显示出错代码块并提示问题发生的确切位置。Full Stack:提供创建Web应用所需的全部功能，集成了Hibernate、OpenID、Memcached等第三方类库。纯Java：Play采用Java编写代码，可以方便地使用任何Java类库，并且能够非常好地和Eclipse、Netbeans等IDE集成，只需通过命令生成匹配的项目文件即可。基于非阻塞的IO模型：允许创建基于长轮询和WebSocket的主流Web应用。有趣并且高效：省去了Java应用重启的时间，提高了应用的开发效率。 1.3 安装1.3.1 环境要求： 运行Play框架，需要Java5或者更高版本。如果读者希望通过源文件构建Play，可以使用Git源码控制客户端来获取源代码，并使用Ant进行构建。 补充：Java的安装： (1)从Oracle官方下载Java最新版本JDK（http://www.oracle.com/technetwork/java/javase/downloads/index.html）。 (2)下载完后安装即可，使用java -version命令进行检查，如果控制台成功显示版本信息则说明Java安装成功。必要的时候需要手动配置环境变量。 Play命令行工具使用的是Python，所以框架能够非常好地在任何Unix系统中工作。如果读者使用的是Windows操作系统，也不必担心，Play框架也附带了Python的Runtime。 提示： Play框架使用Git进行版本控制，并将项目托管在Github上面。Git是源代码管理系统，对于开发者来说，是用于团队协作进行软件开发以及对源代码变更进行跟踪的工具。Github官方：https://github.com/ 1.3.2 下载与安装从Play官方网站 http://www.playframework.com/download 下载最新的1.x版本安装包。提示： 现在官方维护的1.x最稳定版本为play-1.2.7；更新时间为：2013-06-26；下载地址为：http://downloads.typesafe.com/play/1.2.7/play-1.2.7.zip。 下载完毕后，将其解压至本机的某一路径下，如：“D：\\”。为了方便起见，读者需要将框架的安装目录添加至系统PATH，这样在控制台使用命令时就不需要切换到Play安装目录了。如果读者使用的是Unix系统，请确保Play脚本是可运行的（否则需要运行chmod +X Play命令）。以下是Play在Windows环境下配置PATH的操作演示，如图1.5，1.6所示: (图1.5 配置PATH步骤一) (图1.6 配置PATH步骤二) 提示：读者如果因为某些原因需要重建Play框架，只需要在$PLAY_HOME/framework目录下运行Ant即可。 1.3.3 从最新的源文件构建有时候可能需要直接编译最新的Play源码，获得改进和Bug修复后的功能。这里要用到Git客户端工具来获取源码，然后使用Ant构建框架，命令如下：123# git clone git://github.com/playframework/play.git# cd play/framework# ant 至此，Play的安装已经完成，步骤非常简单和方便。接下来开始体验Play开发所带来的高效与乐趣。 1.3.4 Play命令使用 Play框架正确安装后,打开命令提示符窗口进入Play根目录执行Play命令，如图1.7所示。 (图1.7 安装完成执行Play) 如果控制台出现图1.7所示的界面代表Play可以正常运行。读者可以使用play help command-name命令查看指定命令的帮助说明（比如执行play help run命令可以获得关于Play启动命令的相关帮助）。 1.3.5 创建一个新的应用 接下来使用play new命令创建一个全新的Play应用。使用命令创建Play应用时，必须指定空目录来存放创建的应用，否则框架会提示路径已存在。应用创建成功界面如图1.8所示。 (1)新建应用，应用名称为：oopsplay play new oopsplay(图1.8 应用创建成功) (2)应用创建失败，原因是路径已存在，如图1.9所示。 图片资源/new_exists_play.png (图1.9 应用创建失败，路径已存在) Play应用成功创建后，我们可以使用play run命令启动应用，如图1.10所示： play run oopsplay(图1.10 启动oopsplay应用) 打开浏览器访问http://localhost:9000，就可以看到应用程序的默认页面。至此，简单的Play Web项目就已经构建完成，如图1.11所示。 (图1.11 Play应用程序默认页面) Play框架会跟踪Java源码的变更，发现源文件有更改就进行自动编译并重载。Play的这个特性使得开发变得更加容易，甚至不需要功能完备的IDE，仅使用文本编辑器就可以轻松开发Web应用。由于当前的Java IDE提供了很好的产品特征：自动提示、填充、编译、辅助重构和调试等，因此选择合适的IDE能够大大提高开发效率，目前Play支持Netbeans、Eclipse和IntelliJ IDEA三种集成开发环境。 1.4 IDE配置1.4.1 生成Eclipse配置文件 Play自身提供的命令可以简化Eclipse配置。使用play eclipsify命令可以将Play应用转化为Eclipse项目，如图1.12所示： play eclipsify oopsplay(图1.12 使用命令生成Eclipse项目) 应用转化为Eclipse项目后，就可以将其导入到workspace，如图1.13，1.14，1.15所示。 图片资源/import.png(图1.13 点击Import) 图片资源/import2.png(图1.14 选择将已存在的项目导入workspace) 图片资源/import3.png(图1.15 选择新创建的oopsplay项目) play eclipsify命令为应用生成了一些启动项。其中主启动项（项目名称.launch）只能够配合Eclipse中的Run As命令使用，JPDA启动项可以在任何时候（Conncet JPDA to项目名称.launch）和Debug命令配合使用，用于开启debugging session(停止debugging session不会终止应用服务)。 提示：如果用户对应用做了一些重要的改变(如改变了classpath)，那么需要重新使用play eclipsify命令来生成配置文件。在团队开发的时候不要将这些Eclipse的配置文件提交上去，因为这些自动生成的配置文件包含了对框架绝对路径的参考，每个成员的Play安装路径往往是不一样的，所以必须保持这些Eclipse配置文件的私有性。 1.4.2 生成Netbeans配置文件 Play同样提供了简化Netbeans配置的命令。把现有的Play应用转化为Netbeans项目，可以使用play neatbeansify命令，如图1.16所示： play netbeansify oopsplay图片资源/new_netbeansify_play.png(图1.16 使用命令生成Netbeans项目) 转化完成后，可以将应用作为Netbeans项目开发，如图1.17，1.18所示： 图片资源/netbeans.png(图1.17 Netbeans中选择”打开项目”) 图片资源/import4.png(图1.18 选择新创建的oopsplay项目) 点击运行按钮（或F6）就可以启动应用。当应用开启之后可以在任何时候点击调试按钮（或Ctrl+F5）附加debugging seesion，停止debugging session应用服务不会终止。 提示：同样地，如果用户对应用进行了一些重要的改变(比如改变了classpath),那么需要使用play netbeansify命令重新生成配置文件，而且必须保持配置文件的私有性（针对团队开发）。 1.4.3生成IntelliJ IDEA配置文件 由于IntelliJ IDEA受到越来越多开发者的热捧，Play在1.2版本中增加了对其的支持，只需要简单地使用play idealize命令将现有的Play应用转换为IntelliJ IDEA支持的项目即可： play idealize myApp 将应用导入到IntelliJ中，如图1.19所示：图片资源/intellij.png (图1.19 应用导入IntelliJ) 1.4.4 使用Intype Intype是Windows下一个强大、直观的轻量级快速代码编辑器，而且非常容易扩展和定制，这都归功于它对脚本和本地插件的支持，使得其对任何程序语言或脚本的开发都极其简单、快捷。下载（地址：intype.info）并安装Intype，具体使用如图1.20所示。 图片资源/intype.png(图1.20 Intype使用界面) 1.4.5 手动配置首选的编辑器 由于Play是标准的Java应用，所以不需要任何特定的插件来配合编辑器使用，但是我们也需要了解一些Play工作原理方面的知识： （1）classpath设置 Play应用的classpath按照如下顺序构建： 应用的/conf目录。$PLAY_PATH/framework/play.jar。所有在应用的/lib目录中能找到的jar文件。所有在$PLAY_PATH/framework/lib目录中能找到的jar文件。 提示：如果在应用中使用到了模块（module），那么需要将所有模块的类库（$module/lib 目录）添加到classpath中。 （2）运行Main class 运行play.server.Server类就可以启动Play应用。Play使用application.path系统属性查找应用并运行，典型的设置如下： java -Dapplication.path=”/app/path”…\\（3）Java代理 也可以通过play.jar中的类库加载Java代理，使热交换和重载功能生效，设置如下： java -javaagent:”$PLAY_PATH/framework/play.jar” … 这一步不是必须的，但是在某些情况下会加速类重载。 1.4.6 调试问题 当Java源文件改变时(即保存后)，Play会自动重载Java类（内部自动编译）。由于Java不完全支持类重载，所以很容易使JPDA调试器产生混淆：断点提交可能会失败或者当代码跳转时调试器总在出错行终止。 为了避免上述情况发生，最好的解决方案是在代码更新之后开启新的debugging session。幸运的是，JPDA支持在不重启JVM的情况下连接和断开调试，所以正确的调试工作流如下： 更改源代码。刷新浏览器，查看返回结果，这个时候Play会重载代码变更并且在JVM中重新定义类文件。如果出错，那么需要开启一个新的debugging session进行调试。调试并更正代码。断开调试器。 使用此工作流程，调试器将会与加载到JVM中的代码同步。 1.5 Hello world1.5.1 准备工作 首先确认已经安装了Java5或者更高版本的JDK。由于Play开发会频繁用到命令行，所以建议使用Unix或者Linux操作系统。如果读者使用的是Windows系统，也没有问题，只需要在命令提示行下输入命令即可。其次，准备好文本编辑器，当然也可以使用功能完备的Java IDE（Eclipse或者Neatbeans）。由于Play应用开发的高效性，框架会自行管理编译和部署过程，所以使用简单的文本编辑器（Intype，Textmate，Emacs，VI等）也能够满足开发的基本需求。 1.5.2 项目创建 现在开始创建Hello world应用。新建Play应用相当简单，只需要使用Play提供的play new命令，如图1.21所示。 打开命令行，然后输入： play new helloworld 接着按照提示输入应用的全名：Hello world。 图片资源/helloword.png(图1.21 生成Hello world项目) play new命令新建了目录helloworld/，并在里面生成了Play应用的目录结构，如图1.22所示： 图片资源/目录结构.png(图1.22 Play项目目录结构) 该目录包含以下几个重要部分： app/目录：包含了应用的核心部分，默认分为models，controllers，views三个子目录，当然也能够包含其他Java包。app各个子目录中存放的是*.java源文件以及页面模版文件。 conf/目录：包含了应用的所有配置文件，特别是主配置文件application.conf，定义路由规则的配置文件routes和用于国际化配置的文件messages。 lib/目录：包含了所有可选的标准Java类库（*.jar）。 public/目录：包含了所有公用资源，主要有javascripts，stylesheets和images三个子目录。 test/目录：包含了所有的应用测试，框架集成了JUnit和Selenium测试工具。 提示：由于Play使用UTF-8作为其唯一的编码，所以在这些目录中的文本文件用此字符集来编码就显得尤为重要。读者在开发时，请确保正确设置文本编辑器的编码格式。 如果读者已经是经验丰富的Java开发者，可能很想知道.class文件去哪里了，答案是不存在。Play没有使用任何.class文件，而是直接读取Java源文件。框架底层使用了Eclipse compiler来快速编译Java源文件，实现在开发过程中两个非常重要的特性：第一，检查Java源文件的变更，并在运行时自动重载；第二，Java异常发生时，Play生成更友好的错误报告来准确显示源代码的出错位置。 1.5.3 运行应用 Hello world应用已经成功创建，接下来运行该应用。回到命令行，进入helloworld目录，然后输入：play runplay run命令运行后，Play开始加载应用并通过9000端口开放Web服务，在浏览器中打开http://localhost:9000就能查看刚发布的helloworld应用。新创建的应用都带有标准的欢迎页面，代表项目已经成功运行，如图1.23所示。 图片资源/default page.png(图1.23 标准欢迎页面) 接下来让我们看看这个新的应用是如何显示这个页面的。Play应用的主入口是conf/routes文件，该文件定义了所有可访问的URL。打开默认生成的conf/routes路由文件，可以看到：1GET / Application.index 当Web服务器接收到客户端以GET方式请求根路径时，会调用Application.index方法。Application.index其实是controllers.Application.index的缩略写法，因为controllers包是被默认引入的。 创建标准的Java应用程序时，通常会定义一个方法作为其唯一入口点，比如：123public static void main(String[] args) &#123; ... &#125; 而Play应用拥有多个入口点，每个入口点对应一个URL。对应的Java方法称之为Action，Action定义在特殊的类中，称之为控制器（Controller）。查看controller.Application，打开helloworld/app/controllers/Application.java源文件：1234567891011package controllers; import play.mvc.*; public class Application extends Controller &#123; &gt; public static void index() &#123;&gt;&gt; render();&gt; &#125; &#125; Application控制器继承于play.mvc.Controller。该父类为控制器提供了很多有用的方法，比如在index方法中调用的render()方法。 读者可能会感到奇怪，index()方法（即Action方法）被声明为public static void，而且Play中所有这些Action方法都必须这样定义。方法被定义为static，是因为控制器类从来不会被实例化。标识public是为了授权框架在URL响应时调用Action方法，并且返回结果总是为void。 默认的index()方法很简单，仅仅调用render()方法让框架使用HTML模板进行渲染。调用模板是响应HTTP请求最常见的方式（但不是唯一方式，比如直接以二进制形式响应）。模板是简单的文本文件，保存在app/views/目录下，由于render()方法中没有指定渲染的目标模板，所以框架默认使用与Action同名的HTML模板文件渲染（上例中为：Application/index.html）。 接下来看下模板文件，打开helloworld/app/views/Application/index.html文件：1234#&#123;extends 'main.html' /&#125;#&#123;set title:'Home' /&#125; #&#123;welcome /&#125; 模板内容看起来非常简洁，只有少量的Play标签。#{welcome /}标签生成了在浏览器中看到的欢迎信息。#{extends /}标签告诉Play此模板是从另外的模板（main.html）继承而来。Play的模板具有继承机制，允许重用公共部分，以此达到创建复杂的Web页面的目的。该特性比以往使用include导入更加灵活和高效。打开helloworld/app/views/main.html模板文件：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;#&#123;get 'title' /&#125;&lt;/title&gt;&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"@&#123;'/public/stylesheets/main.css'&#125;\" /&gt; &lt;link rel=\"shortcut icon\" type=\"image/png\" href=\"@&#123;'/public/images/favicon.png'&#125;\" /&gt; &lt;/head&gt; &lt;body&gt; #&#123;doLayout /&#125; &lt;/body&gt;&lt;/html&gt; main.html模板文件中的#{doLayout /}标签用于动态插入子模板的内容，本例中为Application/index.html的内容。 1.5.4 创建表单 下面将从创建表单开始，逐步完成helloworld应用。编辑helloworld/app/views/Application/index.html文件，为模板添加表单功能，用户可以在表单中输入名字：1234567#&#123;extends 'main.html' /&#125;#&#123;set title:'Home' /&#125; &lt;form action=\"@&#123;Application.sayHello()&#125;\" method=\"GET\"&gt; &lt;input type=\"text\" name=\"myName\" /&gt; &lt;input type=\"submit\" value=\"Say hello!\" /&gt;&lt;/form&gt; 注意，在表单的method属性中使用GET提交方法，因为通过GET来提交表单没有任何负面影响并且是幂等的。 补充：从理论上讲，如果请求具有幂等性就可以使用GET，所谓幂等是指多个请求返回相同的结果。实际上，相应的服务器方法可能会以某种方式修改状态，所以一般情况下这是不成立的，只是一种标准。GET与POST的区别在于所能携带信息的大小，在许多情况下，浏览器和服务器会限制URL的长度（GET利用URL向服务器发送数据）。一般来讲，如果请求是从服务器获取数据应该使用GET；换句话说，要避免通过GET方式改变服务器上的状态。当改变服务器上的状态时应该使用POST方法，POST不会限制发送给服务器的信息的大小，而且POST请求不能保证是幂等的。在实际开发过程中，大多数请求可能都是GET请求，不过如果需要，也完全可以使用POST。 form表单中使用@{…}标签请求Play自动生成URL，以便调用Application.sayHello()方法。刷新浏览器查看编辑后的主页，如图1.24所示。 图片资源/No route found.png(图1.24 Play显示错误界面) 应用运行出错。这是因为调用了不存在的Action方法（Application.sayHello），接下来在helloworld/app/controllers/目录中编辑Application.java文件，添加sayHello()方法：123456789101112131415package controllers; import play.mvc.*; public class Application extends Controller &#123; public static void index() &#123; render(); &#125; public static void sayHello(String myName) &#123; render(myName); &#125; &#125; Action方法（sayHello）中声明了myName变量，该变量可以自动匹配HTTP表单提交的myName参数。方法体非常简单，只是调用了render()方法来使用默认模板进行页面的渲染。由于myName的值传递给render()方法，所以默认模板中（sayHello.html）可以使用该值。再次刷新浏览器，表单页面显示正常，如图1.25所示。 图片资源/sayhello.png(图1.25 index.html界面) 在表单中输入名字并提交表单，Play提示出错，如图1.26所示： 图片资源/template not found.png(图1.26 Play显示错误界面) 错误显示得非常直观，Action中调用render(myName)方法采用默认的模板进行渲染，但是该模板并不存在。所以需要在helloworld/app/views/Applicaton/目录中创建sayHello.html模板文件。 1234#&#123;extends 'main.html'/&#125;#&#123;set title:'Home'/&#125;&lt;h1&gt;Hello $&#123;myName ?:'guest'&#125;!&lt;/h1&gt;&lt;a href=\"@&#123;Application.index()&#125;\"&gt;Back to form&lt;&lt;/a&gt; sayHello.html模板添加完毕后，刷新浏览器，应用一切正常，如图1.27所示。图片资源/sayhello-html.png(图1.27 sayHello.html页面) sayHello.html模板代码中使用了Groovy操作符”?:”，该操作符的作用是判断myName参数的值是否为空，若为空则显示默认值。所以如果用户没有在表单中输入任何内容，就会显示Hello guest。 1.5.5 提供更好的URL 查看地址栏中提交后的URL，会发现很长: http://localhost:9000/application/sayhello?myName=guillaume 这样的URL看起来并不简洁，更不用说美观了。这是因为Play使用了catch all默认路由规则： *&gt; /{controller}/{action}&gt;&gt;&gt;{controller}.{action} 可以通过为Application.sayHello方法自定义路由来提供更好的URL。编辑helloworld/conf/routes文件，添加如下路由配置：1GET /hello Application.sayHello 回到表单页面并再次提交表单，检查是否使用了新的URL： http://localhost:9000/hello?myName=guillaume 1.5.6 定制布局 到目前为止，所有应用使用的模板都继承于相同的main.html，编辑helloworld/app/views/main.html，就可以很容易地定制布局：12345678...&lt;body&gt; The Hello world app. &lt;hr/&gt; #&#123;doLayout /&#125;&lt;/body&gt;... 所有继承于main.html模板的页面都有相同的顶部，如图1.28所示。 图片资源/commom header.png(图1.28 index.html界面) 1.5.7 添加验证 Play框架具备了数据验证功能，因此我们可以为表单增加一些验证，使myName参数作为必填项。编辑helloworld/app/controllers/Application.java控制器中的sayHello方法:123456789...public static void sayHello(@Required String myName) &#123; if(validation.hasErrors()) &#123;&gt; flash.error(\"Oops, please enter your name!\");&gt; index(); &#125; render(myName);&#125;... 使用Play提供的数据验证时，别忘了导入play.data.validation.*包。我们为myName参数添加了@Required验证注解，Play会自动检查myName的值是否被填充。如果myName的值为空，验证器会添加一个error对象。验证器的hasErrors()方法用于检查error对象，如果有error对象存在，则可以在Flash作用域中增加错误提示信息并重定向到index Action。 提示：Flash作用域通常用于Action重定向时保存信息（比如错误提示信息）。 接下来需要做的是如何显示这些错误信息。编辑helloworld/app/views/Application/index.html模板文件：12345678910111213#&#123;extends 'main.html' /&#125;#&#123;set title:'Home' /&#125; #&#123;if flash.error&#125; &lt;p style=\"color:#c00\"&gt; $&#123;flash.error&#125; &lt;/p&gt;#&#123;/if&#125; &lt;form action=\"@&#123;Application.sayHello()&#125;\" method=\"GET\"&gt; &lt;input type=\"text\" name=\"myName\" /&gt; &lt;input type=\"submit\" value=\"Say hello!\" /&gt;&lt;/form&gt; #{if}标签判断Flash作用域中是否有错误信息存在，如果存在则直接打印错误信息。刷新浏览器，检查Play提供的验证器是否能够正常工作，如图1.29所示： 图片资源/validation.png(图1.29 显示错误信息) 1.5.8 编写自动测试套件 应用开发完后，需要进行一系列的测试来保证应用的质量。接下来为创建完的应用编写测试套件，由于Hello world应用不需要进行Java逻辑测试，所以编写简单的Selenium就可以测试该Web应用了。Play进行测试的前提是应用需要运行在test模式下。停止应用（Ctel+C）并使用play test命令重启应用。 play test 补充：play test命令和play run命令并没有太多的区别，只不过前者加载了测试运行模块，允许直接在浏览器中运行测试套件。 应用开启test模式后，在浏览器中打开http://localhost:9000/@tests查看测试运行器，选择所有默认的测试并运行，结果应该是全部通过（表现为绿色）。事实上这些默认的测试并没有做任何有意义的事情，如图1.30所示。 图片资源/tests.png(图1.30 运行测试界面) Selenium测试套件是典型的HTML文件，它里面的HTML语法写起来有一些令人乏味（使用HTML table元素来格式化）。值得欣慰的是，Play使用自身的模板引擎和一系列的标签来帮助生成这些语法，为Selenium脚本提供了简单的语法支持。 新建了Play应用后，其默认测试套件已经包含了Selenium测试，打开helloworld/test/Application.test.html测试文件：1234567*&#123; You can use plain selenium command using the selenium tag &#125;* #&#123;selenium&#125; // 打开主页,检查主页没有错误 open('/') assertNotTitle('Application error')#&#123;/selenium&#125; 如果直接运行这个测试应该不会有任何问题出现，它的作用只是打开主页然后检查页面的title不为Application error。接下来为Hello world应用编写相应的Selenium测试，测试结果如图1.31所示：12345678910111213141516171819202122232425262728#&#123;selenium&#125; // 打开主页,检查主页没有错误 open('/') assertNotTitle('Application error') // 断言页面中包含'The Hello world app.'文本 assertTextPresent('The Hello world app.') // 提交表单 clickAndWait('css=input[type=submit]') // 断言页面中包含'Oops, please enter your name!'文本 assertTextPresent('Oops, please enter your name!') // 在输入框中输入名字并提交 type('css=input[type=text]', 'bob') clickAndWait('css=input[type=submit]') // 检查结果 assertTextPresent('Hello bob!') assertTextPresent('The Hello world app.') // 返回 clickAndWait('link=Back to form') // 检查是否返回主页 assertTextNotPresent('Hello bob!')#&#123;/selenium&#125; 图片资源/selenium-test.png(图1.31 测试结果) 本章小结1 本章节主要对Play框架进行了初步的介绍。框架本身基于Java，所以对于Java开发者来说，可以非常平滑地过渡到Play的开发当中。安装过程也非常简单，不需要去额外下载第三方库，框架已经集成了MySQL数据库驱动、Hibernate、Log4j、JUnit等开发Web应用所需要的大部分类库，并且随着框架的更新会引用这些第三方库的最新版本。 敏捷是本书的核心驱动，也是实践的理论依据。开发者不需要改变开发环境，只是以一种更加敏捷的方式进行Web应用开发。本章最后通过Hello world应用，整体介绍了使用Play进行开发的基本流程。","tags":[{"name":"play","slug":"play","permalink":"http://lisxweb.github.io/tags/play/"}]},{"title":"Hello World","date":"2016-11-17T06:42:33.000Z","path":"2016/11/17/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]