<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人日记 nodejs学习。"><meta name="baidu-site-verification" content="7tp9tihrLG"><title>第一章 绪论 | 秋过冬漫长天亮中</title><link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.0.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第一章 绪论</h1><a id="logo" href="/.">秋过冬漫长天亮中</a><p class="description">没有比脚更长的路，走过去，前面是个天！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">第一章 绪论</h1><div class="post-meta">Nov 17, 2016<span> | </span><span class="category"><a href="/categories/play-framework框架/">play framework框架</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/11/17/第一章-绪论/" href="/2016/11/17/第一章-绪论/#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1框架概述"><span class="toc-text">1.1框架概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2框架特性"><span class="toc-text">1.2框架特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-无缝集成现有开发环境"><span class="toc-text">1.2.1 无缝集成现有开发环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-热重载和修改Bug"><span class="toc-text">1.2.2 热重载和修改Bug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-简单的无状态MVC架构"><span class="toc-text">1.2.3 简单的无状态MVC架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-HTTP到代码的映射"><span class="toc-text">1.2.4 HTTP到代码的映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-高效的模板引擎"><span class="toc-text">1.2.5 高效的模板引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-6-内置JPA支持"><span class="toc-text">1.2.6 内置JPA支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-7-测试驱动开发（TDD）"><span class="toc-text">1.2.7 测试驱动开发（TDD）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-8-Full-Stack应用框架"><span class="toc-text">1.2.8 Full Stack应用框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-9-Play的特性总结"><span class="toc-text">1.2.9 Play的特性总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-安装"><span class="toc-text">1.3 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-环境要求："><span class="toc-text">1.3.1 环境要求：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-下载与安装"><span class="toc-text">1.3.2 下载与安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-从最新的源文件构建"><span class="toc-text">1.3.3 从最新的源文件构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-Play命令使用"><span class="toc-text">1.3.4 Play命令使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-5-创建一个新的应用"><span class="toc-text">1.3.5 创建一个新的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-IDE配置"><span class="toc-text">1.4 IDE配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-生成Eclipse配置文件"><span class="toc-text">1.4.1 生成Eclipse配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-生成Netbeans配置文件"><span class="toc-text">1.4.2 生成Netbeans配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3生成IntelliJ-IDEA配置文件"><span class="toc-text">1.4.3生成IntelliJ IDEA配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-4-使用Intype"><span class="toc-text">1.4.4 使用Intype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-5-手动配置首选的编辑器"><span class="toc-text">1.4.5 手动配置首选的编辑器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-6-调试问题"><span class="toc-text">1.4.6 调试问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Hello-world"><span class="toc-text">1.5 Hello world</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-准备工作"><span class="toc-text">1.5.1 准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-项目创建"><span class="toc-text">1.5.2 项目创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-3-运行应用"><span class="toc-text">1.5.3 运行应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-4-创建表单"><span class="toc-text">1.5.4 创建表单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-5-提供更好的URL"><span class="toc-text">1.5.5 提供更好的URL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-6-定制布局"><span class="toc-text">1.5.6 定制布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-7-添加验证"><span class="toc-text">1.5.7 添加验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-8-编写自动测试套件"><span class="toc-text">1.5.8 编写自动测试套件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章小结1"><span class="toc-text">本章小结1</span></a></li></ol></div></div><div class="post-content"><h2 id="1-1框架概述"><a href="#1-1框架概述" class="headerlink" title="1.1框架概述"></a>1.1框架概述</h2><p>Play框架颠覆了臃肿的企业级Java EE规范，以Restful为目标并专注于开发效率，是Java敏捷开发的最佳参考方案。开发者只要具备Java以及数据库的相关基础知识就可以轻松上手，从而让Web应用开发变得更加容易，提高项目催化速度。</p>
<p>作为Full Stack的Java Web应用框架，Play包括了所有开发中涉及的领域：NIO应用容器，无状态MVC模型，Hibernate数据持久化，Groovy模板引擎，以及建立Web应用所需要的各种工具类。需要注意的是，这里虽然使用了Groovy，但只是将其作为页面模板语言，和Freemaker、Velocity使用自己定义的语言是同样的道理。Groovy的成熟以及它和Java的相似性决定了采用Groovy远远好于定义自己的模板语言。</p>
<p><img src="http://7xpgda.com1.z0.glb.clouddn.com/play.png" alt="Alt text" title="框架概述/play.png"></p>
<p>Play的发展历程：</p>
<p>2009年10月19日发布Play 1.0稳定版，引入Groovy作为模板引擎，Python提供跨平台的Shell支持，并提供异步I/O功能。后续针对1.0进行BUG修复，以及新特性的增加：HTM5支持，提供Eclipse插件，模块仓库，App云服务等。<br>2010年9月1日发布Play1.1稳定版本，将HTTP服务器从原来的Apache Mina替换为Jboss Netty，框架开始支持Scala语言，新的缓存特性，Oauth支持等。<br>2011年4月13日发布Play 1.2稳定版本，将内存数据库从原来的HSQLDB转向H2，提供依赖管理，更好的异步特性等。<br>当前最稳定版本为Play 1.2.7，于2013年8月29日发布，可以使用Java7来编写应用。<br>当前最新版本为Play 1.3.0 RC版，于2014年6月26日发布，相信不久后就会有正式版本发布。<br>由于设计的考量，Play已经不采用Servlet/JSP，因而早期Play 0.x版本在发展历程中不做详细介绍。</p>
<h2 id="1-2框架特性"><a href="#1-2框架特性" class="headerlink" title="1.2框架特性"></a>1.2框架特性</h2><blockquote>
<h3 id="1-2-1-无缝集成现有开发环境"><a href="#1-2-1-无缝集成现有开发环境" class="headerlink" title="1.2.1 无缝集成现有开发环境"></a>1.2.1 无缝集成现有开发环境</h3><p>Play1.x是基于Java的Web开发框架，允许开发者使用自己常用的集成开发工具（如Eclipse）和类库。如果读者已经以Java作为开发方向，那么无须进行开发语言、IDE或者类库的切换，要做的就是在更加高效的Java环境中开发Web应用。</p>
<h3 id="1-2-2-热重载和修改Bug"><a href="#1-2-2-热重载和修改Bug" class="headerlink" title="1.2.2 热重载和修改Bug"></a>1.2.2 热重载和修改Bug</h3><p>Java在过去因为开发效率低下而臭名昭著，主要是因为其重复和乏味的编译-打包-部署周期。因此在设计框架的时候对这些因素都进行了重新考量，目标是让Play应用的开发过程变得更加高效。</p>
<p>Play框架会自动编译Java源文件，而不用重新启动Web服务器将代码热加载至JVM。这样做的好处是：当代码修改完保存后，框架自动编译并重载修改后的类，只需刷新浏览器就可以查看更改的结果，就像在LAMP或者Rails环境中开发一样。另外一个好处是：开发的时候甚至可以只用简单的文本编辑器，而不使用功能完备的Java IDE进行开发，如图1.1所示：</p>
</blockquote>
<p><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.2.2.png" alt="Alt text" title="图片资源/editor.png"></p>
<p>(图1.1 简单的文本编辑器)</p>
<blockquote>
<p>使用Play开发应用的过程中，在任何时候出现的语法错误或者异常，框架都能够准确将其定位并显示对应的提示信息。好处显而易见：应用的Bug能够很直观地显示出来，帮助开发者迅速锁定出错位置。如图1.2所示：</p>
</blockquote>
<p><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.2.2.2.png" alt="Alt text" title="图片资源/guide1-3.png"></p>
<p>(图1.2 框架准确定位错误代码位置)</p>
<blockquote>
<p>Play框架替换了原有以栈跟踪的方式来提示错误，取而代之的是在浏览器中以更加友好并且直观的页面形式来显示错误出现的确切位置(当然在控制台中仍以栈跟踪的方式显示错误信息)。此外，Play还把模板执行发生的异常信息完美地集成到了Java栈跟踪里面，如图1.3所示：</p>
</blockquote>
<p><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.2.2.3.png" alt="Alt text" title="图片资源/stacktrace.png"></p>
<p>(图1.3 模板执行出错后的Java堆栈跟踪)</p>
<blockquote>
<h3 id="1-2-3-简单的无状态MVC架构"><a href="#1-2-3-简单的无状态MVC架构" class="headerlink" title="1.2.3 简单的无状态MVC架构"></a>1.2.3 简单的无状态MVC架构</h3><p>一端是数据库，另一端是Web浏览器，为什么我们需要在这两者之间保存状态？</p>
<p>有状态并且基于组件的Java Web框架能够更加容易地保存页面状态，但这同样带来了很多其他的问题：如果用户在新的浏览器窗口中重新打开应用会发生什么？用户按了后退按钮又会是什么结果？</p>
<p>无共享架构是很多Web应用框架所提倡的（ROR，Django等）。由于浏览器变得越来越强大，我们并不需要技巧性地构建HTTP模型来创建伪造的状态，只需在客户端使用Ajax或者离线存储技术就可以很容易地解决状态问题。无共享架构的另一优势是使页面的呈现更加平滑，更容易地实现局部页面更新（或者渐进式的页面处理流程）。</p>
<h3 id="1-2-4-HTTP到代码的映射"><a href="#1-2-4-HTTP到代码的映射" class="headerlink" title="1.2.4 HTTP到代码的映射"></a>1.2.4 HTTP到代码的映射</h3><p>如果读者使用过其他的Java Web框架（比如说Struts）可能会发现，这些框架的底层实现其实是对HTTP协议做了进一步封装，所以它们提供的Java API和自身的理念会让人觉得很不自然。Play框架在设计过程中换了一种思维方式，即Web应用框架也应该提供完整、直接的方式去访问HTTP————这也是Play框架和其他Java Web框架最根本的差异。</p>
<p>HTTP，Request/Response模式，Rest架构风格，HTTP内容协商（Content–type negotiation），URI等等，所有这些都是Play框架的主要概念。如果用户需要将URI绑定到指定的Java方法调用，只需要在路由文件中以如下方式进行配置：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET    /clients/&#123;<span class="built_in">id</span>&#125;&gt;  Clients.show</div></pre></td></tr></table></figure></p>
<p>如果Ajax，REST以及管理页面之间的“前进/后退”操作是日常开发中需要频繁考虑的需求，那么Play框架无疑是最佳的选择，因为针对这些问题它都提供了非常优秀的解决方案。</p>
<h3 id="1-2-5-高效的模板引擎"><a href="#1-2-5-高效的模板引擎" class="headerlink" title="1.2.5 高效的模板引擎"></a>1.2.5 高效的模板引擎</h3><p>也许读者已经深深地感受到了JSP和表达式语言背后的理念，但是为什么在创建标签库的时候需要如此多的配置文件？为什么不能直接访问底层的模型对象？JSP中太多的限制确实让开发者感到失望，受JSP启发又不被其约束，Play框架提供了自定义的模板引擎机制。</p>
<p>开发者再也不需要编写这些令人厌倦的代码了：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> <span class="attr">prefix</span>=<span class="string">"c"</span> %&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/functions"</span> <span class="attr">prefix</span>=<span class="string">"fn"</span> %&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;<span class="name">c:choose</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">c:when</span> <span class="attr">test</span>=<span class="string">"$</span></span><span class="template-variable">&#123;emails.unread != null &amp;&amp; fn:size(emails.unread)&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></div><div class="line">&gt;  You have $<span class="template-variable">&#123;fn:size(emails.unread)&#125;</span><span class="xml"> unread email(s)!</span></div><div class="line">    <span class="tag">&lt;/<span class="name">c:when</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">c:otherwise</span>&gt;</span></div><div class="line">&gt;  You have no unread emails!</div><div class="line">    <span class="tag">&lt;/<span class="name">c:otherwise</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">c:choose</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>相信开发者更倾向于用以下方式来书写模板代码：</p>
</blockquote>
<p>You have ${emails.unread ?: ‘no’} ${emails.unread?.pluralize(‘email’)} !</p>
<blockquote>
<p>Play模板引擎使用的表达式语言为Groovy，它提供了与Java一致的语法。Play主要使用模板机制来渲染HTML，当然也可以生成其他的文档格式，比如e-mail messages，JSON等等。</p>
<h3 id="1-2-6-内置JPA支持"><a href="#1-2-6-内置JPA支持" class="headerlink" title="1.2.6 内置JPA支持"></a>1.2.6 内置JPA支持</h3><p>JPA（Java Persistence API）是Java中最简洁的对象关系映射（object-relational mapping即ORM）API。如果读者以前了解或者使用过JPA，就会发现与其他框架相比，在Play中使用会更加方便。这是因为Play框架对其做了进一步封装，不需要任何配置，Play会自动开启JPA实体管理器（EM），一旦代码被调用就自动进行持久化操作。</p>
<p>此外，实体如果继承Play提供的play.db.jpa.Model类，操作代码将会更加简洁，更加美观：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> messages(<span class="keyword">int</span> page) &#123;</div><div class="line">    User connectedUser = User.<span class="built_in">find</span>(<span class="string">"byEmail"</span>, <span class="built_in">connected</span>()).first();</div><div class="line">    List&lt;Message&gt; messages = Message.<span class="built_in">find</span>(</div><div class="line">&gt;  <span class="string">"user = ? and read = false order by date desc"</span>,</div><div class="line">&gt;  connectedUser</div><div class="line">    ).from(page * <span class="number">10</span>).fetch(<span class="number">10</span>);</div><div class="line">    render(connectedUser, messages);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-2-7-测试驱动开发（TDD）"><a href="#1-2-7-测试驱动开发（TDD）" class="headerlink" title="1.2.7 测试驱动开发（TDD）"></a>1.2.7 测试驱动开发（TDD）</h3><p>框架集成的测试运行器（Test Runner）让测试驱动开发变的非常简单。Play允许开发者编写各种类型的测试，从基本的单元测试到完善的验收测试，以及直接在浏览器中运行的Selenium测试。值得注意的是，这些测试还可以进行代码覆盖率的统计，具体的测试界面如图1.4所示。</p>
</blockquote>
<p><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.2.7.png" alt="Alt text" title="图片资源/guide2-2.png"></p>
<p>(图1.4 浏览器中的测试运行器)</p>
<blockquote>
<h3 id="1-2-8-Full-Stack应用框架"><a href="#1-2-8-Full-Stack应用框架" class="headerlink" title="1.2.8 Full Stack应用框架"></a>1.2.8 Full Stack应用框架</h3><p>Play框架的最初设计受到实际Java Web开发的启发，包含了所有创建主流Web应用所需要的工具：</p>
</blockquote>
<p>通过JDBC提供关系数据库支持。<br>使用Hibernate进行对象关系映射（JPA）。<br>使用分布式Memcached集成缓存支持。<br>以JSON或者XML的形式提供web service支持。<br>基于OpenID的分布式用户信息验证。<br>Web应用可以部署在任何应用服务器上（Tomcat，Jboss，GAE，Cloud等）。<br>图像处理API（验证码）。</p>
<blockquote>
<p>此外Play还提供了很多实用的模块。开发者可以结合这些模块构建Web应用，这使得我们可以以更加简单，更加直接的方式重用Java代码、模板以及静态资源（比如JavaScript和CSS文件）。</p>
<h3 id="1-2-9-Play的特性总结"><a href="#1-2-9-Play的特性总结" class="headerlink" title="1.2.9 Play的特性总结"></a>1.2.9 Play的特性总结</h3></blockquote>
<p>自动编译和重载：当编辑Java文件并保存后，刷新浏览器就能立即查看结果。使用Play开发不需要手动编译、部署以及重新启动Web服务器等操作。<br>无状态模型：Play是真正的无共享框架，为REST而准备。它可以将同一个应用的多个实例分别部署在多台服务器上，因而扩展性非常强。<br>高效的模板引擎：基于表达式语言Groovy的清晰模板引擎，提供了模板的继承、导入以及标签自定义等功能。<br>快速解决错误：当错误发生时，Play会在浏览器中显示出错代码块并提示问题发生的确切位置。<br>Full Stack:提供创建Web应用所需的全部功能，集成了Hibernate、OpenID、Memcached等第三方类库。<br>纯Java：Play采用Java编写代码，可以方便地使用任何Java类库，并且能够非常好地和Eclipse、Netbeans等IDE集成，只需通过命令生成匹配的项目文件即可。<br>基于非阻塞的IO模型：允许创建基于长轮询和WebSocket的主流Web应用。<br>有趣并且高效：省去了Java应用重启的时间，提高了应用的开发效率。</p>
<h2 id="1-3-安装"><a href="#1-3-安装" class="headerlink" title="1.3 安装"></a>1.3 安装</h2><h3 id="1-3-1-环境要求："><a href="#1-3-1-环境要求：" class="headerlink" title="1.3.1 环境要求："></a>1.3.1 环境要求：</h3><blockquote>
<p>运行Play框架，需要Java5或者更高版本。如果读者希望通过源文件构建Play，可以使用Git源码控制客户端来获取源代码，并使用Ant进行构建。</p>
</blockquote>
<p>补充：<br>Java的安装：</p>
<p>(1)从Oracle官方下载Java最新版本JDK（<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html）。" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/index.html）。</a></p>
<p>(2)下载完后安装即可，使用java -version命令进行检查，如果控制台成功显示版本信息则说明Java安装成功。必要的时候需要手动配置环境变量。</p>
<blockquote>
<p>Play命令行工具使用的是Python，所以框架能够非常好地在任何Unix系统中工作。如果读者使用的是Windows操作系统，也不必担心，Play框架也附带了Python的Runtime。</p>
</blockquote>
<p>提示：</p>
<p>Play框架使用Git进行版本控制，并将项目托管在Github上面。Git是源代码管理系统，对于开发者来说，是用于团队协作进行软件开发以及对源代码变更进行跟踪的工具。Github官方：<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a></p>
<blockquote>
<h3 id="1-3-2-下载与安装"><a href="#1-3-2-下载与安装" class="headerlink" title="1.3.2 下载与安装"></a>1.3.2 下载与安装</h3><p>从Play官方网站 <a href="http://www.playframework.com/download" target="_blank" rel="external">http://www.playframework.com/download</a> 下载最新的1.x版本安装包。<br>提示：</p>
</blockquote>
<p>现在官方维护的1.x最稳定版本为play-1.2.7；更新时间为：2013-06-26；下载地址为：<a href="http://downloads.typesafe.com/play/1.2.7/play-1.2.7.zip。" target="_blank" rel="external">http://downloads.typesafe.com/play/1.2.7/play-1.2.7.zip。</a></p>
<blockquote>
<p>下载完毕后，将其解压至本机的某一路径下，如：“D：\”。为了方便起见，读者需要将框架的安装目录添加至系统PATH，这样在控制台使用命令时就不需要切换到Play安装目录了。如果读者使用的是Unix系统，请确保Play脚本是可运行的（否则需要运行chmod +X Play命令）。以下是Play在Windows环境下配置PATH的操作演示，如图1.5，1.6所示:</p>
</blockquote>
<p><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.3.2.1.png" alt="Alt text" title="图片资源"><br>(图1.5 配置PATH步骤一)</p>
<p><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.3.2.2.png" alt="Alt text" title="图片资源"><br>(图1.6 配置PATH步骤二)</p>
<p>提示：<br>读者如果因为某些原因需要重建Play框架，只需要在$PLAY_HOME/framework目录下运行Ant即可。</p>
<blockquote>
<h3 id="1-3-3-从最新的源文件构建"><a href="#1-3-3-从最新的源文件构建" class="headerlink" title="1.3.3 从最新的源文件构建"></a>1.3.3 从最新的源文件构建</h3><p>有时候可能需要直接编译最新的Play源码，获得改进和Bug修复后的功能。这里要用到Git客户端工具来获取源码，然后使用Ant构建框架，命令如下：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># git clone git://github.com/playframework/play.git</span></div><div class="line"><span class="meta"># cd play/framework</span></div><div class="line"><span class="meta"># ant</span></div></pre></td></tr></table></figure></p>
<p>至此，Play的安装已经完成，步骤非常简单和方便。接下来开始体验Play开发所带来的高效与乐趣。</p>
</blockquote>
<h3 id="1-3-4-Play命令使用"><a href="#1-3-4-Play命令使用" class="headerlink" title="1.3.4 Play命令使用"></a>1.3.4 Play命令使用</h3><blockquote>
<p>Play框架正确安装后,打开命令提示符窗口进入Play根目录执行Play命令，如图1.7所示。</p>
</blockquote>
<p><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.3.4.png" alt="Alt text" title="图片资源"><br>(图1.7 安装完成执行Play)</p>
<blockquote>
<p>如果控制台出现图1.7所示的界面代表Play可以正常运行。读者可以使用play help command-name命令查看指定命令的帮助说明（比如执行play help run命令可以获得关于Play启动命令的相关帮助）。</p>
</blockquote>
<h3 id="1-3-5-创建一个新的应用"><a href="#1-3-5-创建一个新的应用" class="headerlink" title="1.3.5 创建一个新的应用"></a>1.3.5 创建一个新的应用</h3><blockquote>
<p>接下来使用play new命令创建一个全新的Play应用。使用命令创建Play应用时，必须指定空目录来存放创建的应用，否则框架会提示路径已存在。应用创建成功界面如图1.8所示。</p>
<p>(1)新建应用，应用名称为：oopsplay</p>
</blockquote>
<p>play new oopsplay<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.3.5.1.png" alt="Alt text" title="图片资源"><br>(图1.8 应用创建成功)</p>
<blockquote>
<p>(2)应用创建失败，原因是路径已存在，如图1.9所示。</p>
</blockquote>
<p>图片资源/new_exists_play.png</p>
<p>(图1.9 应用创建失败，路径已存在)</p>
<blockquote>
<p>Play应用成功创建后，我们可以使用play run命令启动应用，如图1.10所示：</p>
</blockquote>
<p>play run oopsplay<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.3.5.2.png" alt="Alt text" title="图片资源"><br>(图1.10 启动oopsplay应用)</p>
<blockquote>
<p>打开浏览器访问<a href="http://localhost:9000，就可以看到应用程序的默认页面。至此，简单的Play" target="_blank" rel="external">http://localhost:9000，就可以看到应用程序的默认页面。至此，简单的Play</a> Web项目就已经构建完成，如图1.11所示。</p>
</blockquote>
<p><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.3.5.3.png" alt="Alt text" title="图片资源"><br>(图1.11 Play应用程序默认页面)</p>
<blockquote>
<p>Play框架会跟踪Java源码的变更，发现源文件有更改就进行自动编译并重载。Play的这个特性使得开发变得更加容易，甚至不需要功能完备的IDE，仅使用文本编辑器就可以轻松开发Web应用。由于当前的Java IDE提供了很好的产品特征：自动提示、填充、编译、辅助重构和调试等，因此选择合适的IDE能够大大提高开发效率，目前Play支持Netbeans、Eclipse和IntelliJ IDEA三种集成开发环境。</p>
</blockquote>
<h2 id="1-4-IDE配置"><a href="#1-4-IDE配置" class="headerlink" title="1.4 IDE配置"></a>1.4 IDE配置</h2><h3 id="1-4-1-生成Eclipse配置文件"><a href="#1-4-1-生成Eclipse配置文件" class="headerlink" title="1.4.1 生成Eclipse配置文件"></a>1.4.1 生成Eclipse配置文件</h3><blockquote>
<p>Play自身提供的命令可以简化Eclipse配置。使用play eclipsify命令可以将Play应用转化为Eclipse项目，如图1.12所示：</p>
</blockquote>
<p>play eclipsify oopsplay<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.4.1.1.png" alt="Alt text" title="图片资源"><br>(图1.12 使用命令生成Eclipse项目)</p>
<blockquote>
<p>应用转化为Eclipse项目后，就可以将其导入到workspace，如图1.13，1.14，1.15所示。</p>
</blockquote>
<p>图片资源/import.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.4.1.2.png" alt="Alt text" title="图片资源"><br>(图1.13 点击Import)</p>
<p>图片资源/import2.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.4.1.3.png" alt="Alt text" title="图片资源"><br>(图1.14 选择将已存在的项目导入workspace)</p>
<p>图片资源/import3.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.4.1.4.png" alt="Alt text" title="图片资源"><br>(图1.15 选择新创建的oopsplay项目)</p>
<blockquote>
<p>play eclipsify命令为应用生成了一些启动项。其中主启动项（项目名称.launch）只能够配合Eclipse中的Run As命令使用，JPDA启动项可以在任何时候（Conncet JPDA to项目名称.launch）和Debug命令配合使用，用于开启debugging session(停止debugging session不会终止应用服务)。</p>
</blockquote>
<p>提示：<br>如果用户对应用做了一些重要的改变(如改变了classpath)，那么需要重新使用play eclipsify命令来生成配置文件。在团队开发的时候不要将这些Eclipse的配置文件提交上去，因为这些自动生成的配置文件包含了对框架绝对路径的参考，每个成员的Play安装路径往往是不一样的，所以必须保持这些Eclipse配置文件的私有性。</p>
<h3 id="1-4-2-生成Netbeans配置文件"><a href="#1-4-2-生成Netbeans配置文件" class="headerlink" title="1.4.2 生成Netbeans配置文件"></a>1.4.2 生成Netbeans配置文件</h3><blockquote>
<p>Play同样提供了简化Netbeans配置的命令。把现有的Play应用转化为Netbeans项目，可以使用play neatbeansify命令，如图1.16所示：</p>
</blockquote>
<p>play netbeansify oopsplay<br>图片资源/new_netbeansify_play.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.4.2.png" alt="Alt text" title="图片资源"><br>(图1.16 使用命令生成Netbeans项目)</p>
<blockquote>
<p>转化完成后，可以将应用作为Netbeans项目开发，如图1.17，1.18所示：</p>
</blockquote>
<p>图片资源/netbeans.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.4.2.2.png" alt="Alt text" title="图片资源"><br>(图1.17 Netbeans中选择”打开项目”)</p>
<p>图片资源/import4.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.4.2.3.png" alt="Alt text" title="图片资源"><br>(图1.18 选择新创建的oopsplay项目)</p>
<blockquote>
<p>点击运行按钮（或F6）就可以启动应用。当应用开启之后可以在任何时候点击调试按钮（或Ctrl+F5）附加debugging seesion，停止debugging session应用服务不会终止。</p>
</blockquote>
<p>提示：<br>同样地，如果用户对应用进行了一些重要的改变(比如改变了classpath),那么需要使用play netbeansify命令重新生成配置文件，而且必须保持配置文件的私有性（针对团队开发）。</p>
<h3 id="1-4-3生成IntelliJ-IDEA配置文件"><a href="#1-4-3生成IntelliJ-IDEA配置文件" class="headerlink" title="1.4.3生成IntelliJ IDEA配置文件"></a>1.4.3生成IntelliJ IDEA配置文件</h3><blockquote>
<p>由于IntelliJ IDEA受到越来越多开发者的热捧，Play在1.2版本中增加了对其的支持，只需要简单地使用play idealize命令将现有的Play应用转换为IntelliJ IDEA支持的项目即可：</p>
</blockquote>
<p>play idealize myApp</p>
<blockquote>
<p>将应用导入到IntelliJ中，如图1.19所示：<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.4.3.1.png" alt="Alt text" title="图片资源"><br>图片资源/intellij.png</p>
</blockquote>
<p>(图1.19 应用导入IntelliJ)</p>
<h3 id="1-4-4-使用Intype"><a href="#1-4-4-使用Intype" class="headerlink" title="1.4.4 使用Intype"></a>1.4.4 使用Intype</h3><blockquote>
<p>Intype是Windows下一个强大、直观的轻量级快速代码编辑器，而且非常容易扩展和定制，这都归功于它对脚本和本地插件的支持，使得其对任何程序语言或脚本的开发都极其简单、快捷。下载（地址：intype.info）并安装Intype，具体使用如图1.20所示。</p>
</blockquote>
<p>图片资源/intype.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.4.4.1.png" alt="Alt text" title="图片资源"><br>(图1.20 Intype使用界面)</p>
<h3 id="1-4-5-手动配置首选的编辑器"><a href="#1-4-5-手动配置首选的编辑器" class="headerlink" title="1.4.5 手动配置首选的编辑器"></a>1.4.5 手动配置首选的编辑器</h3><blockquote>
<p>由于Play是标准的Java应用，所以不需要任何特定的插件来配合编辑器使用，但是我们也需要了解一些Play工作原理方面的知识：</p>
</blockquote>
<p>（1）classpath设置</p>
<blockquote>
<p>Play应用的classpath按照如下顺序构建：</p>
</blockquote>
<p>应用的/conf目录。<br>$PLAY_PATH/framework/play.jar。<br>所有在应用的/lib目录中能找到的jar文件。<br>所有在$PLAY_PATH/framework/lib目录中能找到的jar文件。</p>
<p>提示：<br>如果在应用中使用到了模块（module），那么需要将所有模块的类库（$module/lib 目录）添加到classpath中。</p>
<p>（2）运行Main class</p>
<blockquote>
<p>运行play.server.Server类就可以启动Play应用。Play使用application.path系统属性查找应用并运行，典型的设置如下：</p>
</blockquote>
<p>java -Dapplication.path=”/app/path”…\<br>（3）Java代理</p>
<blockquote>
<p>也可以通过play.jar中的类库加载Java代理，使热交换和重载功能生效，设置如下：</p>
</blockquote>
<p>java -javaagent:”$PLAY_PATH/framework/play.jar” …</p>
<blockquote>
<p>这一步不是必须的，但是在某些情况下会加速类重载。</p>
</blockquote>
<h3 id="1-4-6-调试问题"><a href="#1-4-6-调试问题" class="headerlink" title="1.4.6 调试问题"></a>1.4.6 调试问题</h3><blockquote>
<p>当Java源文件改变时(即保存后)，Play会自动重载Java类（内部自动编译）。由于Java不完全支持类重载，所以很容易使JPDA调试器产生混淆：断点提交可能会失败或者当代码跳转时调试器总在出错行终止。</p>
<p>为了避免上述情况发生，最好的解决方案是在代码更新之后开启新的debugging session。幸运的是，JPDA支持在不重启JVM的情况下连接和断开调试，所以正确的调试工作流如下：</p>
</blockquote>
<p>更改源代码。<br>刷新浏览器，查看返回结果，这个时候Play会重载代码变更并且在JVM中重新定义类文件。<br>如果出错，那么需要开启一个新的debugging session进行调试。<br>调试并更正代码。<br>断开调试器。</p>
<blockquote>
<p>使用此工作流程，调试器将会与加载到JVM中的代码同步。</p>
</blockquote>
<h2 id="1-5-Hello-world"><a href="#1-5-Hello-world" class="headerlink" title="1.5 Hello world"></a>1.5 Hello world</h2><h3 id="1-5-1-准备工作"><a href="#1-5-1-准备工作" class="headerlink" title="1.5.1 准备工作"></a>1.5.1 准备工作</h3><blockquote>
<p>首先确认已经安装了Java5或者更高版本的JDK。由于Play开发会频繁用到命令行，所以建议使用Unix或者Linux操作系统。如果读者使用的是Windows系统，也没有问题，只需要在命令提示行下输入命令即可。其次，准备好文本编辑器，当然也可以使用功能完备的Java IDE（Eclipse或者Neatbeans）。由于Play应用开发的高效性，框架会自行管理编译和部署过程，所以使用简单的文本编辑器（Intype，Textmate，Emacs，VI等）也能够满足开发的基本需求。</p>
</blockquote>
<h3 id="1-5-2-项目创建"><a href="#1-5-2-项目创建" class="headerlink" title="1.5.2 项目创建"></a>1.5.2 项目创建</h3><blockquote>
<p>现在开始创建Hello world应用。新建Play应用相当简单，只需要使用Play提供的play new命令，如图1.21所示。 打开命令行，然后输入：</p>
</blockquote>
<p>play new helloworld </p>
<blockquote>
<p>接着按照提示输入应用的全名：Hello world。</p>
</blockquote>
<p>图片资源/helloword.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.5.2.1.png" alt="Alt text" title="图片资源"><br>(图1.21 生成Hello world项目)</p>
<blockquote>
<p>play new命令新建了目录helloworld/，并在里面生成了Play应用的目录结构，如图1.22所示：</p>
</blockquote>
<p>图片资源/目录结构.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.5.2.2.png" alt="Alt text" title="图片资源"><br>(图1.22 Play项目目录结构)</p>
<blockquote>
<p>该目录包含以下几个重要部分：</p>
<p>app/目录：包含了应用的核心部分，默认分为models，controllers，views三个子目录，当然也能够包含其他Java包。app各个子目录中存放的是*.java源文件以及页面模版文件。</p>
<p>conf/目录：包含了应用的所有配置文件，特别是主配置文件application.conf，定义路由规则的配置文件routes和用于国际化配置的文件messages。</p>
<p>lib/目录：包含了所有可选的标准Java类库（*.jar）。</p>
<p>public/目录：包含了所有公用资源，主要有javascripts，stylesheets和images三个子目录。</p>
<p>test/目录：包含了所有的应用测试，框架集成了JUnit和Selenium测试工具。</p>
</blockquote>
<p>提示：<br>由于Play使用UTF-8作为其唯一的编码，所以在这些目录中的文本文件用此字符集来编码就显得尤为重要。读者在开发时，请确保正确设置文本编辑器的编码格式。</p>
<blockquote>
<p>如果读者已经是经验丰富的Java开发者，可能很想知道.class文件去哪里了，答案是不存在。Play没有使用任何.class文件，而是直接读取Java源文件。框架底层使用了Eclipse compiler来快速编译Java源文件，实现在开发过程中两个非常重要的特性：第一，检查Java源文件的变更，并在运行时自动重载；第二，Java异常发生时，Play生成更友好的错误报告来准确显示源代码的出错位置。</p>
</blockquote>
<h3 id="1-5-3-运行应用"><a href="#1-5-3-运行应用" class="headerlink" title="1.5.3 运行应用"></a>1.5.3 运行应用</h3><blockquote>
<p>Hello world应用已经成功创建，接下来运行该应用。回到命令行，进入helloworld目录，然后输入：<br>play run<br>play run命令运行后，Play开始加载应用并通过9000端口开放Web服务，在浏览器中打开<a href="http://localhost:9000就能查看刚发布的helloworld应用。新创建的应用都带有标准的欢迎页面，代表项目已经成功运行，如图1.23所示。" target="_blank" rel="external">http://localhost:9000就能查看刚发布的helloworld应用。新创建的应用都带有标准的欢迎页面，代表项目已经成功运行，如图1.23所示。</a></p>
</blockquote>
<p>图片资源/default page.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.5.3.png" alt="Alt text" title="图片资源"><br>(图1.23 标准欢迎页面)</p>
<blockquote>
<p>接下来让我们看看这个新的应用是如何显示这个页面的。Play应用的主入口是conf/routes文件，该文件定义了所有可访问的URL。打开默认生成的conf/routes路由文件，可以看到：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET  /     Application.<span class="keyword">index</span></div></pre></td></tr></table></figure></p>
<p>当Web服务器接收到客户端以GET方式请求根路径时，会调用Application.index方法。Application.index其实是controllers.Application.index的缩略写法，因为controllers包是被默认引入的。</p>
<p>创建标准的Java应用程序时，通常会定义一个方法作为其唯一入口点，比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  ... </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而Play应用拥有多个入口点，每个入口点对应一个URL。对应的Java方法称之为Action，Action定义在特殊的类中，称之为控制器（Controller）。查看controller.Application，打开helloworld/app/controllers/Application.java源文件：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> controllers;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> play.mvc.*;</div><div class="line"> </div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</div><div class="line"> </div><div class="line">&gt;  public static void index() &#123;</div><div class="line">&gt;&gt;    render();</div><div class="line">&gt;  &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Application控制器继承于play.mvc.Controller。该父类为控制器提供了很多有用的方法，比如在index方法中调用的render()方法。</p>
<p>读者可能会感到奇怪，index()方法（即Action方法）被声明为public static void，而且Play中所有这些Action方法都必须这样定义。方法被定义为static，是因为控制器类从来不会被实例化。标识public是为了授权框架在URL响应时调用Action方法，并且返回结果总是为void。</p>
<p>默认的index()方法很简单，仅仅调用render()方法让框架使用HTML模板进行渲染。调用模板是响应HTTP请求最常见的方式（但不是唯一方式，比如直接以二进制形式响应）。模板是简单的文本文件，保存在app/views/目录下，由于render()方法中没有指定渲染的目标模板，所以框架默认使用与Action同名的HTML模板文件渲染（上例中为：Application/index.html）。</p>
<p>接下来看下模板文件，打开helloworld/app/views/Application/index.html文件：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#&#123;<span class="ruby">extends <span class="string">'main.html'</span> /&#125;</span></div><div class="line">#&#123;<span class="ruby">set <span class="symbol">title:</span><span class="string">'Home'</span> /&#125;</span></div><div class="line"> </div><div class="line">#&#123;<span class="ruby">welcome /&#125;</span></div></pre></td></tr></table></figure></p>
<p>模板内容看起来非常简洁，只有少量的Play标签。#{welcome /}标签生成了在浏览器中看到的欢迎信息。#{extends /}标签告诉Play此模板是从另外的模板（main.html）继承而来。Play的模板具有继承机制，允许重用公共部分，以此达到创建复杂的Web页面的目的。该特性比以往使用include导入更加灵活和高效。打开helloworld/app/views/main.html模板文件：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE html&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>#<span class="template-variable">&#123;get 'title' /&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span>&gt;   </span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"screen"</span> </span></div><div class="line">  <span class="attr">href</span>=<span class="string">"@</span><span class="template-variable">&#123;'/public/stylesheets/main.css'&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> /&gt;</span></span></div><div class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">type</span>=<span class="string">"image/png"</span> </span></div><div class="line">  <span class="attr">href</span>=<span class="string">"@</span><span class="template-variable">&#123;'/public/images/favicon.png'&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> /&gt;</span></span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  #<span class="template-variable">&#123;doLayout /&#125;</span><span class="xml"> </span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>main.html模板文件中的#{doLayout /}标签用于动态插入子模板的内容，本例中为Application/index.html的内容。</p>
</blockquote>
<h3 id="1-5-4-创建表单"><a href="#1-5-4-创建表单" class="headerlink" title="1.5.4 创建表单"></a>1.5.4 创建表单</h3><blockquote>
<p>下面将从创建表单开始，逐步完成helloworld应用。编辑helloworld/app/views/Application/index.html文件，为模板添加表单功能，用户可以在表单中输入名字：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#&#123;extends 'main.html' /&#125;</div><div class="line">#&#123;set title:'Home' /&#125;</div><div class="line"> </div><div class="line">&lt;form action=<span class="string">"@&#123;Application.sayHello()&#125;"</span> method=<span class="string">"<span class="keyword">GET</span>"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"myName"</span> /&gt; </div><div class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Say hello!"</span> /&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>注意，在表单的method属性中使用GET提交方法，因为通过GET来提交表单没有任何负面影响并且是幂等的。</p>
</blockquote>
<p>补充：<br>从理论上讲，如果请求具有幂等性就可以使用GET，所谓幂等是指多个请求返回相同的结果。实际上，相应的服务器方法可能会以某种方式修改状态，所以一般情况下这是不成立的，只是一种标准。GET与POST的区别在于所能携带信息的大小，在许多情况下，浏览器和服务器会限制URL的长度（GET利用URL向服务器发送数据）。一般来讲，如果请求是从服务器获取数据应该使用GET；换句话说，要避免通过GET方式改变服务器上的状态。当改变服务器上的状态时应该使用POST方法，POST不会限制发送给服务器的信息的大小，而且POST请求不能保证是幂等的。在实际开发过程中，大多数请求可能都是GET请求，不过如果需要，也完全可以使用POST。</p>
<blockquote>
<p>form表单中使用@{…}标签请求Play自动生成URL，以便调用Application.sayHello()方法。刷新浏览器查看编辑后的主页，如图1.24所示。</p>
</blockquote>
<p>图片资源/No route found.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/1.5.4.png" alt="Alt text" title="图片资源"><br>(图1.24 Play显示错误界面)</p>
<blockquote>
<p>应用运行出错。这是因为调用了不存在的Action方法（Application.sayHello），接下来在helloworld/app/controllers/目录中编辑Application.java文件，添加sayHello()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> controllers;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> play.mvc.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">()</span> </span>&#123;</div><div class="line">    render();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String myName)</span> </span>&#123;</div><div class="line">    render(myName);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Action方法（sayHello）中声明了myName变量，该变量可以自动匹配HTTP表单提交的myName参数。方法体非常简单，只是调用了render()方法来使用默认模板进行页面的渲染。由于myName的值传递给render()方法，所以默认模板中（sayHello.html）可以使用该值。再次刷新浏览器，表单页面显示正常，如图1.25所示。</p>
</blockquote>
<p>图片资源/sayhello.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/sayhello.png" alt="Alt text" title="图片资源"><br>(图1.25 index.html界面)</p>
<blockquote>
<p>在表单中输入名字并提交表单，Play提示出错，如图1.26所示：</p>
</blockquote>
<p>图片资源/template not found.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/template not found.png" alt="Alt text" title="图片资源"><br>(图1.26 Play显示错误界面)</p>
<blockquote>
<p>错误显示得非常直观，Action中调用render(myName)方法采用默认的模板进行渲染，但是该模板并不存在。所以需要在helloworld/app/views/Applicaton/目录中创建sayHello.html模板文件。</p>
</blockquote>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="xml">#</span><span class="template-variable">&#123;extends 'main.html'/&#125;</span><span class="xml"></span></div><div class="line">#<span class="template-variable">&#123;set title:'Home'/&#125;</span><span class="xml"></span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello $<span class="template-variable">&#123;myName ?:'guest'&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"@</span></span><span class="template-variable">&#123;Application.index()&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>Back to form<span class="tag">&lt;&lt;/<span class="attr">a</span>&gt;</span></span></div></pre></td></tr></table></figure>
<blockquote>
<p>sayHello.html模板添加完毕后，刷新浏览器，应用一切正常，如图1.27所示。<br>图片资源/sayhello-html.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/sayhello-html.png" alt="Alt text" title="图片资源"><br>(图1.27 sayHello.html页面)</p>
<p>sayHello.html模板代码中使用了Groovy操作符”?:”，该操作符的作用是判断myName参数的值是否为空，若为空则显示默认值。所以如果用户没有在表单中输入任何内容，就会显示Hello guest。</p>
</blockquote>
<h3 id="1-5-5-提供更好的URL"><a href="#1-5-5-提供更好的URL" class="headerlink" title="1.5.5 提供更好的URL"></a>1.5.5 提供更好的URL</h3><blockquote>
<p>查看地址栏中提交后的URL，会发现很长:</p>
</blockquote>
<p><a href="http://localhost:9000/application/sayhello?myName=guillaume" target="_blank" rel="external">http://localhost:9000/application/sayhello?myName=guillaume</a></p>
<blockquote>
<p>这样的URL看起来并不简洁，更不用说美观了。这是因为Play使用了catch all默认路由规则：</p>
</blockquote>
<p>*&gt; /{controller}/{action}&gt;&gt;&gt;{controller}.{action}</p>
<blockquote>
<p>可以通过为Application.sayHello方法自定义路由来提供更好的URL。编辑helloworld/conf/routes文件，添加如下路由配置：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">GET</span>     /hello     Application.sayHello</div></pre></td></tr></table></figure></p>
<p>回到表单页面并再次提交表单，检查是否使用了新的URL：</p>
</blockquote>
<p><a href="http://localhost:9000/hello?myName=guillaume" target="_blank" rel="external">http://localhost:9000/hello?myName=guillaume</a></p>
<h3 id="1-5-6-定制布局"><a href="#1-5-6-定制布局" class="headerlink" title="1.5.6 定制布局"></a>1.5.6 定制布局</h3><blockquote>
<p>到目前为止，所有应用使用的模板都继承于相同的main.html，编辑helloworld/app/views/main.html，就可以很容易地定制布局：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="params">&lt;body&gt;</span></div><div class="line">    The Hello world app.</div><div class="line">    <span class="params">&lt;hr/&gt;</span></div><div class="line">    </div><div class="line">    <span class="meta">#&#123;doLayout /&#125;</span></div><div class="line"><span class="params">&lt;/body&gt;</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>所有继承于main.html模板的页面都有相同的顶部，如图1.28所示。</p>
</blockquote>
<p>图片资源/commom header.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/commom header.png" alt="Alt text" title="图片资源"><br>(图1.28 index.html界面)</p>
<h3 id="1-5-7-添加验证"><a href="#1-5-7-添加验证" class="headerlink" title="1.5.7 添加验证"></a>1.5.7 添加验证</h3><blockquote>
<p>Play框架具备了数据验证功能，因此我们可以为表单增加一些验证，使myName参数作为必填项。编辑helloworld/app/controllers/Application.java控制器中的sayHello方法:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">sayHello</span>(<span class="variable">@Required</span> String myName) &#123;</div><div class="line">    <span class="selector-tag">if</span>(validation.hasErrors()) &#123;</div><div class="line">&gt;  <span class="selector-tag">flash</span><span class="selector-class">.error</span>(<span class="string">"Oops, please enter your name!"</span>);</div><div class="line">&gt;  <span class="selector-tag">index</span>();</div><div class="line">    &#125;</div><div class="line">    <span class="selector-tag">render</span>(myName);</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>使用Play提供的数据验证时，别忘了导入play.data.validation.*包。我们为myName参数添加了@Required验证注解，Play会自动检查myName的值是否被填充。如果myName的值为空，验证器会添加一个error对象。验证器的hasErrors()方法用于检查error对象，如果有error对象存在，则可以在Flash作用域中增加错误提示信息并重定向到index Action。</p>
</blockquote>
<p>提示：<br>Flash作用域通常用于Action重定向时保存信息（比如错误提示信息）。</p>
<blockquote>
<p>接下来需要做的是如何显示这些错误信息。编辑helloworld/app/views/Application/index.html模板文件：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="xml">#</span><span class="template-variable">&#123;extends 'main.html' /&#125;</span><span class="xml"></span></div><div class="line">#<span class="template-variable">&#123;set title:'Home' /&#125;</span><span class="xml"></span></div><div class="line"> </div><div class="line">#<span class="template-variable">&#123;<span class="keyword">if</span> flash.error&#125;</span><span class="xml"></span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:#c00"</span>&gt;</span></div><div class="line">    $<span class="template-variable">&#123;flash.error&#125;</span><span class="xml"></span></div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">#<span class="template-tag">&#123;/<span class="name">if</span>&#125;</span><span class="xml"></span></div><div class="line"> </div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"@</span></span><span class="template-variable">&#123;Application.sayHello()&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">method</span>=<span class="string">"GET"</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"myName"</span> /&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Say hello!"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>#{if}标签判断Flash作用域中是否有错误信息存在，如果存在则直接打印错误信息。刷新浏览器，检查Play提供的验证器是否能够正常工作，如图1.29所示：</p>
</blockquote>
<p>图片资源/validation.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/validation.png" alt="Alt text" title="图片资源"><br>(图1.29 显示错误信息)</p>
<h3 id="1-5-8-编写自动测试套件"><a href="#1-5-8-编写自动测试套件" class="headerlink" title="1.5.8 编写自动测试套件"></a>1.5.8 编写自动测试套件</h3><blockquote>
<p>应用开发完后，需要进行一系列的测试来保证应用的质量。接下来为创建完的应用编写测试套件，由于Hello world应用不需要进行Java逻辑测试，所以编写简单的Selenium就可以测试该Web应用了。Play进行测试的前提是应用需要运行在test模式下。停止应用（Ctel+C）并使用play test命令重启应用。</p>
</blockquote>
<p>play test</p>
<p>补充：<br>play test命令和play run命令并没有太多的区别，只不过前者加载了测试运行模块，允许直接在浏览器中运行测试套件。</p>
<blockquote>
<p>应用开启test模式后，在浏览器中打开<a href="http://localhost:9000/@tests查看测试运行器，选择所有默认的测试并运行，结果应该是全部通过（表现为绿色）。事实上这些默认的测试并没有做任何有意义的事情，如图1.30所示。" target="_blank" rel="external">http://localhost:9000/@tests查看测试运行器，选择所有默认的测试并运行，结果应该是全部通过（表现为绿色）。事实上这些默认的测试并没有做任何有意义的事情，如图1.30所示。</a></p>
</blockquote>
<p>图片资源/tests.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/tests.png" alt="Alt text" title="图片资源"><br>(图1.30 运行测试界面)</p>
<blockquote>
<p>Selenium测试套件是典型的HTML文件，它里面的HTML语法写起来有一些令人乏味（使用HTML table元素来格式化）。值得欣慰的是，Play使用自身的模板引擎和一系列的标签来帮助生成这些语法，为Selenium脚本提供了简单的语法支持。</p>
<p>新建了Play应用后，其默认测试套件已经包含了Selenium测试，打开helloworld/test/Application.test.html测试文件：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">*&#123; You can use plain selenium command <span class="keyword">using</span> the selenium tag &#125;*</div><div class="line"> </div><div class="line"><span class="meta">#&#123;selenium&#125;</span></div><div class="line">    <span class="comment">// 打开主页,检查主页没有错误</span></div><div class="line">    open(<span class="string">'/'</span>)</div><div class="line">    assertNotTitle(<span class="string">'Application error'</span>)</div><div class="line"><span class="meta">#&#123;/selenium&#125;</span></div></pre></td></tr></table></figure></p>
<p>如果直接运行这个测试应该不会有任何问题出现，它的作用只是打开主页然后检查页面的title不为Application error。接下来为Hello world应用编写相应的Selenium测试，测试结果如图1.31所示：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#&#123;selenium&#125;</span></div><div class="line">    <span class="comment">// 打开主页,检查主页没有错误</span></div><div class="line">    open(<span class="string">'/'</span>)</div><div class="line">    assertNotTitle(<span class="string">'Application error'</span>)</div><div class="line">    </div><div class="line">    <span class="comment">// 断言页面中包含'The Hello world app.'文本</span></div><div class="line">    assertTextPresent(<span class="string">'The Hello world app.'</span>)</div><div class="line">    </div><div class="line">    <span class="comment">// 提交表单</span></div><div class="line">    clickAndWait(<span class="string">'css=input[type=submit]'</span>)</div><div class="line">    </div><div class="line">    <span class="comment">// 断言页面中包含'Oops, please enter your name!'文本</span></div><div class="line">    assertTextPresent(<span class="string">'Oops, please enter your name!'</span>)</div><div class="line">    </div><div class="line">    <span class="comment">// 在输入框中输入名字并提交</span></div><div class="line">    type(<span class="string">'css=input[type=text]'</span>, <span class="string">'bob'</span>)</div><div class="line">    clickAndWait(<span class="string">'css=input[type=submit]'</span>)</div><div class="line">    </div><div class="line">    <span class="comment">// 检查结果</span></div><div class="line">    assertTextPresent(<span class="string">'Hello bob!'</span>)</div><div class="line">    assertTextPresent(<span class="string">'The Hello world app.'</span>)</div><div class="line">    </div><div class="line">    <span class="comment">// 返回</span></div><div class="line">    clickAndWait(<span class="string">'link=Back to form'</span>)</div><div class="line">    </div><div class="line">    <span class="comment">// 检查是否返回主页</span></div><div class="line">    assertTextNotPresent(<span class="string">'Hello bob!'</span>)</div><div class="line"><span class="meta">#&#123;/selenium&#125;</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>图片资源/selenium-test.png<br><img src="http://7xpgda.com1.z0.glb.clouddn.com/selenium-test.png" alt="Alt text" title="图片资源"><br>(图1.31 测试结果)</p>
<h2 id="本章小结1"><a href="#本章小结1" class="headerlink" title="本章小结1"></a>本章小结1</h2><p> 本章节主要对Play框架进行了初步的介绍。框架本身基于Java，所以对于Java开发者来说，可以非常平滑地过渡到Play的开发当中。安装过程也非常简单，不需要去额外下载第三方库，框架已经集成了MySQL数据库驱动、Hibernate、Log4j、JUnit等开发Web应用所需要的大部分类库，并且随着框架的更新会引用这些第三方库的最新版本。</p>
<blockquote>
<p>敏捷是本书的核心驱动，也是实践的理论依据。开发者不需要改变开发环境，只是以一种更加敏捷的方式进行Web应用开发。本章最后通过Hello world应用，整体介绍了使用Play进行开发的基本流程。</p>
</blockquote>
</div><div class="tags"><a href="/tags/play/">play</a></div><div class="post-nav"><a href="/2016/11/18/第二章-基础概念/" class="pre">第二章 基础概念</a><a href="/2016/11/17/hello-world/" class="next">Hello World</a></div><div data-thread-key="2016/11/17/第一章-绪论/" data-title="第一章 绪论" data-url="http://lisxweb.github.io/2016/11/17/第一章-绪论/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/11/17/第一章-绪论/" data-title="第一章 绪论" data-url="http://lisxweb.github.io/2016/11/17/第一章-绪论/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux服务器/">Linux服务器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MAC实用/">MAC实用</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/play-framework框架/">play framework框架</a><span class="category-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Linux服务器/" style="font-size: 15px;">Linux服务器</a> <a href="/tags/play/" style="font-size: 15px;">play</a> <a href="/tags/MAC-Eclipse-快捷键/" style="font-size: 15px;">MAC Eclipse 快捷键</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/11/24/第五章-模板引擎/">第五章 模板引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/23/第四章-控制层/">第四章 控制层</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/22/第三章-路由语法/">第三章 路由语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/整理MAC下Eclipse的常用快捷键/">整理MAC下Eclipse的常用快捷键</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/Linux服务器增量备份脚步/">Linux服务器增量备份脚本</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/第二章-基础概念/">第二章 基础概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/第一章-绪论/">第一章 绪论</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-commt"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:zhenggchaoo@gmail.com" target="_blank" class="fa fa-email"> </a><a href="http://weibo.com/zhengchaooo" target="_blank" class="fa fa-weibo"></a><a href="https://github.com/chaooo" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">lisxweb</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script>var duoshuoQuery = {short_name:'lisx'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    document.getElementsByTagName('body')[0].appendChild(ds);
})();
</script><script type="text/javascript" src="/js/search.json.js?v=1.0.0"></script></body></html>