<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人日记 nodejs学习。"><meta name="baidu-site-verification" content="7tp9tihrLG"><title>第六章 域模型 | 秋过冬漫长天亮中</title><link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.0.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第六章 域模型</h1><a id="logo" href="/.">秋过冬漫长天亮中</a><p class="description">没有比脚更长的路，走过去，前面是个天！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">第六章 域模型</h1><div class="post-meta">Nov 24, 2016<span> | </span><span class="category"><a href="/categories/play-framework框架/">play framework框架</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/11/24/第六章-域模型/" href="/2016/11/24/第六章-域模型/#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1属性模拟"><span class="toc-text">6.1属性模拟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2数据库配置"><span class="toc-text">6.2数据库配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3数据持久化"><span class="toc-text">6.3数据持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4无状态模型"><span class="toc-text">6.4无状态模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5本章小结"><span class="toc-text">6.5本章小结</span></a></li></ol></div></div><div class="post-content"><p>模型（Model）在Play应用中处于非常核心的地位，是应用对操作信息的特定域的表现形式。</p>
<p>Martin fowler做了如下的定义:模型层负责表示业务概念，业务状况的信息及其规则。尽管保存这些内容的技术细节由基础架构来完成，但反映了上述信息是在模型层中被控制和使用的，因而在软件业务开发当中处于非常核心的地位。</p>
<p>普遍使用的Java设计模式是尽可能地将模型定义为一些简单的Java Bean，然后将应用的业务逻辑放到用来操作这些模型的service层。在Play中，将这种传统的设计模式定义为反模式。</p>
<p>补充：<br>反模式：在开发、设计、管理中采用的糟糕的解决方案。</p>
<p>与优秀的改进型模式相反，反模式告诉我们应该尽量避免这些糟糕的模式而采用优秀的模式，以此起到警示作用。但反模式不是固定的，其中的“良好”或“糟糕”是对应于一定的环境而言的，因为一种良好的设计如果应用在错误的环境下也可能成为一种反模式。</p>
<p>Martin fowler将上述的这种反模式命名为贫血模型（Anemic object model）：贫血域模型(Anemic Domain Model)最基本的表现是乍一看跟真实世界中的区别不大，有对象，有许多以名词命名的域空间。将这些对象与那些真实域模型进行对照，会发现两者在宏观的关系和结构方面有着紧密的联系。但美中不足的是当我们仔细观察其行为时，会意识到除了getXxx和setXxx方法以外很难发现有基于对象自身的操作。这些模型拥有约定俗成的设计规则：不要将业务逻辑放到域模型中，取而代之的是将这些逻辑交给上面的service层去处理，间接使用模型来对数据进行操作。</p>
<p>这个反模式最大的恐怖之处在于，它与面向对象设计中的基本概念背道而驰，因为它没有将数据和操作放在一起。贫血域模型实际上仅仅是面向过程的设计风格，而且这种设计风格是面向对象的设计者们所反对的。可现在的情况是很多人认为贫血对象就是真实的对象，因此完全错过了去挖掘面向对象设计究竟是怎么一回事的机会。</p>
<h2 id="6-1属性模拟"><a href="#6-1属性模拟" class="headerlink" title="6.1属性模拟"></a>6.1属性模拟</h2><p>查看Play提供的示例应用，模型类里面会频繁地使用声明为public的变量。即使是经验尚浅的Java开发者，也懂得慎用public类型的变量。在Java开发中（当然还有其他的面向对象语言），实践经验是这样告诉我们的：将所有的成员变量声明为私有，只提供获取与修改的方法。这样做的目的在于增强程序的封装性，而“封装”在面向对象设计中恰恰是非常关键的概念。</p>
<p>Java没有真正的内置属性定义机制，而是使用Java Bean来进行约束：Java对象的属性通过一对getXxx/setXxx的方法来修改，如果对象是只读的那么只需要提供getXxx方法。在过去的开发中我们一直这样做，但是编码过程就显得有些乏味了。每个属性必须声明为private，同时还有相应的getXxx/setXxx方法，而且大多数情况下，getXxx和setXxx方法的实现都是类似的。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> String name;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(<span class="params">String <span class="keyword">value</span></span>) </span>&#123;</div><div class="line">    name = <span class="keyword">value</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Play框架的模型部分会自动生成getXxx/setXxx方法，保持代码的简洁。也就是说，在Play中开发者可以直接把属性变量声明为public，运行时Play会自动生成相应的getXxx/setXxx方法（在这里我们将声明为public的字段都视为属性）。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="built_in">Product</span> &#123;</div><div class="line">    <span class="keyword">public</span> String <span class="keyword">name</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">Integer</span> price;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码被框架载入后就会转换成如下形式：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span> &#123;</div><div class="line">    <span class="keyword">public</span> String name;</div><div class="line">    <span class="keyword">public</span> Integer price;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(<span class="params">String name</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getPrice</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> price;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span>(<span class="params">Integer price</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.price = price;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为变量被声明为public，可以使用如下方式对属性进行操作：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">product.name = <span class="string">"My product"</span><span class="comment">;</span></div><div class="line">product.price = <span class="number">58</span><span class="comment">;</span></div><div class="line">程序在加载时会自动地转换成：</div><div class="line">product.setName(<span class="string">"My product"</span>)<span class="comment">;</span></div><div class="line">product.setPrice(<span class="number">58</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>注意：<br>因为这些getXxx/setXxx方法是在运行时动态生成的，所以不能直接调用。如果在编码阶段使用他们，编译器会因为找不到该方法而报错误。</p>
<p>当然也可以自己定义相应的getXxx/setXxx方法，Play会优先选择手动编写的方法。如果需要保护Product类的price属性就可以定义setPrice()方法：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span> &#123;</div><div class="line">    <span class="keyword">public</span> String name;</div><div class="line">    <span class="keyword">public</span> Integer price;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span>(<span class="params">Integer price</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (price &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Price can’t be negative!"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.price = price;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果为Product类的price属性赋负值就会抛出异常：<br>product.price = -10: // Oops! IllegalArgumentException<br>Play总会优先使用已经定义的getXxx/setXxx方法：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@Entity</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Data</span> <span class="title">extends</span> <span class="title">Model</span> &#123;</div><div class="line">   @Required</div><div class="line">   <span class="keyword">public</span> String <span class="keyword">value</span>;</div><div class="line">   <span class="keyword">public</span> Integer anotherValue;</div><div class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">getAnotherValue</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">if</span>(anotherValue == <span class="literal">null</span>) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> anotherValue;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnotherValue</span>(<span class="params">Integer <span class="keyword">value</span></span>) </span>&#123;</div><div class="line">       <span class="keyword">if</span>(<span class="keyword">value</span> == <span class="literal">null</span>) &#123;</div><div class="line">           <span class="keyword">this</span>.anotherValue = <span class="literal">null</span>;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">this</span>.anotherValue = <span class="keyword">value</span> * <span class="number">2</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; </div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">value</span> + <span class="string">" - "</span> + anotherValue;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>补充：<br>@Entity注解的作用是通知Play自动开启JPA实体管理器，@Required是对该属性的约束。该类继承于play.db.jpa.Model，Model提供了非常简单的对象处理方式，在后面章节会做详细介绍。</p>
<p>针对以上例子可以进行如下测试断言：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="type">Data</span> <span class="class"><span class="keyword">data</span> = new <span class="type">Data</span>();</span></div><div class="line"><span class="class"><span class="keyword">data</span>.anotherValue = null;</span></div><div class="line"><span class="title">assert</span> <span class="class"><span class="keyword">data</span>.anotherValue == 0;</span></div><div class="line"><span class="class"><span class="keyword">data</span>.anotherValue = 4</span></div><div class="line"><span class="title">assert</span> <span class="class"><span class="keyword">data</span>.anotherValue == 8;</span></div></pre></td></tr></table></figure></p>
<p>以上的断言都会执行通过，而且因为这种改进的类遵从JavaBean规范，可以满足开发中的更复杂需求。</p>
<h2 id="6-2数据库配置"><a href="#6-2数据库配置" class="headerlink" title="6.2数据库配置"></a>6.2数据库配置</h2><p>通常情况下，开发者需要将模型对象持久化。最常用的方法是把这些数据保存到数据库中。</p>
<p>在Play应用的开发过程中，开发者可以迅速配置嵌入式内存数据库或者直接将数据保存到文件系统中。开启内存数据库H2，只需要在conf/application.conf文件中进行如下配置：</p>
<p>db=mem</p>
<p>补充：<br>H2是开放源代码的Java数据库，其具有标准的SQL语法和Java接口，可以自由使用和分发，且非常简洁和快速。将数据保存在内存中相比从磁盘上访问能够极大地提高应用的性能，但由于内存容量的限制，内存数据库适用于开发阶段，或者原型示例开发。</p>
<p>如果需要将数据保存在文件系统中，则使用如下配置：</p>
<p>db=fs<br>如果需要连接到MySQL服务器，则使用如下配置：<br>db=mysql:user:pwd@database_name<br>Play框架集成了H2数据库和MySQL数据库的驱动程序，存放在$PLAY_HOME/framework/lib/目录下。如果需要使用PostgreSQL，Oracle或者其他数据库，需要在该目录（或者应用程序的lib/目录）下添加相应的数据库驱动。</p>
<p>Play可以连接任何JDBC兼容的数据库，只需要将相应的驱动类库添加到/lib目录中，并在conf/application.conf文件中定义JDBC配置：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">db</span>.url=jdbc:mysql:<span class="comment">//localhost/test</span></div><div class="line"><span class="keyword">db</span>.driver=com.mysql.jdbc.Driver</div><div class="line"><span class="keyword">db</span>.user=root</div><div class="line"><span class="keyword">db</span>.pass=123456</div><div class="line">还可以在<span class="keyword">conf</span>/application.<span class="keyword">conf</span>文件中用配置选项指定JPA方言：</div><div class="line">jpa.dialect=&lt;dialect&gt;</div></pre></td></tr></table></figure></p>
<p>补充：<br>由于不同的数据库产品支持不同的ANSI SQL标准，所以Hibernate必须要使用“方言”才能与各种数据库成功的进行通信。在Play中，大多数情况下会自动根据配置信息识别特定数据库方言，但是存在某些数据库，Play无法判断其使用的方言。这时就需要开发者显式地在Play配置文件中指定。</p>
<p>除了使用Hibernate外，在编码时还可以直接从play.db.DB中获得java.sql.Connection，然后使用标准SQL语句来执行数据库操作。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Connection conn = DB.getConnection()<span class="comment">;</span></div><div class="line">conn.createStatement().execute(<span class="string">"select * from products"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<h2 id="6-3数据持久化"><a href="#6-3数据持久化" class="headerlink" title="6.3数据持久化"></a>6.3数据持久化</h2><p>Play的持久层框架采用的是Hibernate，使用Hibernate（通过JPA）自动地将Java对象持久化到数据库。当在任意的实体类上增加@javax.persistence.Entity注解后，Play会自动为其开启JPA实体管理器。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Entity</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="built_in">Product</span> &#123;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> String <span class="keyword">name</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">Integer</span> price; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：<br>Play应用开发者一开始可能经常会犯的错误是使用Hibernate的@Entity注解来取代JPA。这里请读者注意，Play是直接调用JPA的API来使用Hibernate。</p>
<p>也可以直接从play.db.jpa.JPA对象中得到实体管理器，通过实体管理器可以将Model持久化到数据库或者执行HQL语句，例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="type">EntityManager</span> em = <span class="type">JPA</span>.em();</div><div class="line">em.persist(product);</div><div class="line">em.createQuery(<span class="string">"from Product where price &gt; 50"</span>).getResultList();</div><div class="line"><span class="type">Play</span>为<span class="type">JPA</span>的使用提供了非常好的支持，只需要继承<span class="type">Play</span>提供的play.db.jpa.<span class="type">Model</span>类：</div><div class="line"></div><div class="line"><span class="meta">@Entity</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">extends</span> <span class="title">Model</span> </span>&#123;</div><div class="line"> </div><div class="line">    public <span class="type">String</span> name;</div><div class="line">    public <span class="type">Integer</span> price; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着就可以执行Product实例中CRUD操作进行对象持久化：<br>Product.find(“price &gt; ?”, 50).fetch();<br>Product product = Product.findById(2L);<br>product.save();<br>product.delete();<br>补充：ActiveRecord模式<br>ActiveRecord也属于ORM层，由Rails最早提出，遵循标准的ORM模型：表映射到记录，记录映射到对象，字段映射到对象属性。配合遵循的命名和配置惯例，能够很大程度的快速实现模型的操作，而且简洁易懂。Play也提倡使用ActiveRecord模式进行快速开发，其主要思想是：</p>
<p>每一个数据库表对应创建一个类，类的每一个对象实例对应于数据库中表的一行记录；通常表的每个字段在类中都有相应的Field；<br>ActiveRecord同时负责把自己持久化，在ActiveRecord中封装了对数据库的访问，即CURD；<br>ActiveRecord是一种领域模型(Domain Model)，封装了部分业务逻辑。</p>
<h2 id="6-4无状态模型"><a href="#6-4无状态模型" class="headerlink" title="6.4无状态模型"></a>6.4无状态模型</h2><p> Play被设计成为“无共享”的架构，目的就是为了保持应用的完全无状态化。这样做的好处在于可以让一个应用同一时刻在多个服务器节点上运行。</p>
<p>Play为了保持模型无状态化，需要避免一些常见的陷阱，最重要的就是不要因为多请求而将对象保存到Java堆中。Play应用中多请求之间保存数据有以下几种解决方案：</p>
<p>1.如果数据很小而且非常简单，那么可以将其存储在Session或者Flash作用域，但是这些作用域最大只允许存放4K的内容，并且存储的数据只能为字符串类型。</p>
<p>2.将数据保存到持久化存储中（数据库或者文件系统）。比如用户创建了需要跨越多个请求的对象，就可以按照以下步骤对其进行操作：</p>
<p>在第一次请求时初始化对象并将它保存到数据库中。<br>将创建的对象的id保存在Flash作用域中。<br>在以后不停的请求链执行过程中，使用id从数据库中获取对象，更新并重新保存它。</p>
<p>3.将数据保存在瞬时存储中（比如Cache）：</p>
<p>在第一次请求时初始化对象并将它保存在缓存中。<br>将创建的对象的id保存在Flash作用域中。<br>在请求链的执行过程中，从Cache里获取对象（通过保存在Flash作用域中的对象id），更新后并将它再次保存回Cache。<br>当请求链结束后，将对象进行持久化操作（数据库或者文件系统）。</p>
<p>根据具体应用的需求，第三种解决方案使用缓存可以是一种非常好的选择，也是Java Servlet Session的良好的替代方案。但缓存并不是可靠的数据存储方式，因此如果选择将对象保存到缓存中，就必须确保能够将它重新读取回来。</p>
<h2 id="6-5本章小结"><a href="#6-5本章小结" class="headerlink" title="6.5本章小结"></a>6.5本章小结</h2><p>本章重点介绍了Play中域模型的核心功能。数据是应用最有价值的部分，而对数据的操作也是令很多开发者觉得非常繁琐的事情。使用传统的JDBC需要书写大量的SQL语句，还会碰到“方言”的问题(比如不同数据库产品的查询语句存在差别)，而且在一些场合下甚至还需要将参数包装到某个对象后返回给视图进行显示。</p>
<p>Play提供的Model解决了开发过程中的数据持久化问题。针对数据的CRUD（即增删改查）操作，Play做了进一步的封装，大大降低开发成本，减少重复操作。开发过程中并没有大量的配置文件，而是通过注解的方式来维护模型之间的关系以及级联处理等开发中常用的操作。Play支持所有JDBC兼容的数据库，也可以使用JDBC来书写查询语句(但是并不提倡这么做)。另外需要提的一点是：Play还集成了NoSQL(比如当前使用率比较高的MongoDB)，因为非关系数据库在查询以及非结构化数据存储方面有极大的优势，如果读者感兴趣，可以参阅相关主题资料，书中没有深入展开。</p>
</div><div class="tags"><a href="/tags/play/">play</a></div><div class="post-nav"><a href="/2016/11/24/第七章-Job异步处理/" class="pre">第七章 Job异步处理</a><a href="/2016/11/24/第五章-模板引擎/" class="next">第五章 模板引擎</a></div><div data-thread-key="2016/11/24/第六章-域模型/" data-title="第六章 域模型" data-url="http://lisxweb.github.io/2016/11/24/第六章-域模型/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/11/24/第六章-域模型/" data-title="第六章 域模型" data-url="http://lisxweb.github.io/2016/11/24/第六章-域模型/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux服务器/">Linux服务器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MAC实用/">MAC实用</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/play-framework框架/">play framework框架</a><span class="category-list-count">9</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Linux服务器/" style="font-size: 15px;">Linux服务器</a> <a href="/tags/MAC-Eclipse-快捷键/" style="font-size: 15px;">MAC Eclipse 快捷键</a> <a href="/tags/play/" style="font-size: 15px;">play</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/11/28/README/">README</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/25/第九章-测试/">第九章 测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/24/第八章-HTTP异步编程/">第八章 HTTP异步编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/24/第七章-Job异步处理/">第七章 Job异步处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/24/第六章-域模型/">第六章 域模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/24/第五章-模板引擎/">第五章 模板引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/23/第四章-控制层/">第四章 控制层</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/22/第三章-路由语法/">第三章 路由语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/整理MAC下Eclipse的常用快捷键/">整理MAC下Eclipse的常用快捷键</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/Linux服务器增量备份脚步/">Linux服务器增量备份脚本</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-commt"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:zhenggchaoo@gmail.com" target="_blank" class="fa fa-email"> </a><a href="http://weibo.com/zhengchaooo" target="_blank" class="fa fa-weibo"></a><a href="https://github.com/chaooo" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">lisxweb</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script>var duoshuoQuery = {short_name:'lisx'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    document.getElementsByTagName('body')[0].appendChild(ds);
})();
</script><script type="text/javascript" src="/js/search.json.js?v=1.0.0"></script></body></html>