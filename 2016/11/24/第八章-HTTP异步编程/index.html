<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人日记 nodejs学习。"><meta name="baidu-site-verification" content="7tp9tihrLG"><title>第八章 HTTP异步编程 | 秋过冬漫长天亮中</title><link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.0.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第八章 HTTP异步编程</h1><a id="logo" href="/.">秋过冬漫长天亮中</a><p class="description">没有比脚更长的路，走过去，前面是个天！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">第八章 HTTP异步编程</h1><div class="post-meta">Nov 24, 2016<span> | </span><span class="category"><a href="/categories/play-framework框架/">play framework框架</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/11/24/第八章-HTTP异步编程/" href="/2016/11/24/第八章-HTTP异步编程/#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div></div></div><div class="post-content"><p>这一章节将介绍如何编写异步的Play应用程序，特别是针对常见的长轮询(long-polling)以及流式响应(streaming)等请求方式，并具体介绍如何通过Play构建支持高并发量的应用。<br>8.1挂起HTTP请求<br>8.1.1 HTTP请求挂起#</p>
<p>Play的设计初衷在于完成较短的请求。通过HTTP接口，Play使用固定的线程池来处理请求队列。为了达到理想的效果，线程池应该设计得尽可能小。最典型的情况：以处理程序的数量+1作为最佳值来设定线程池的大小。<br>这意味着如果某个请求非常耗时(比如处理长时间的运算)，它将会阻塞线程池并且影响应用程序的响应能力。当然，可以通过增大线程池大小来解决问题，但是这样会造成资源的极大浪费，而且线程池的大小也不可能无止尽地增大。</p>
<p>试想聊天应用程序的例子：浏览器发送一个阻塞的HTTP请求，这个HTTP请求的作用是等待新消息后显示。这种类型的HTTP请求会占用很长时间(通常是好几秒)，从而导致线程池的阻塞。如果有100个用户同时连接这个聊天应用程序，那么至少需要提供100个线程。这还是可以接受的，如果有1000个用户呢？甚至有10000个呢？</p>
<p>为了解决这种情况，Play允许临时挂起HTTP请求。挂起的HTTP请求仍然保持连接，但是该请求的执行会被移出线程池并稍后进行尝试。根据需要，Play可以在一段固定的延时后恢复现场，继续执行请求。</p>
<p>下例Action使用now()方法调用ReportAsPDFJob，该Job需要较长的处理时间。按照正常的情况，程序必须等待ReportAsPDFJob执行完后，才能向HTTP发送响应结果：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generatePDF</span>(<span class="params">Long reportId</span>) </span>&#123;</div><div class="line">    Promise&lt;InputStream&gt; pdf = <span class="keyword">new</span> ReportAsPDFJob(report).now();</div><div class="line">    InputStream pdfStream = <span class="keyword">await</span>(pdf);</div><div class="line">    renderBinary(pdfStream);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Play提供了更加高效的解决方案，调用await()方法将请求挂起，并释放占用的线程。当Promise<inputstream>完成后，恢复现场，继续执行后续操作。</inputstream></p>
<p>8.1.2 Continuations#</p>
<p>如果请求非常耗时，就把正在执行的代码挂起，并将占用的线程释放出来为其他的请求提供服务。这种高效的解决方案称为Continuations。在Play的早期版本中并没有await()方法，但可以等价地使用waitFor()方法。两者的效果相同，waitFor()方法也是将Action挂起，并在需要的时候重新调用。<br>在应用中引入Continuations技术是为了使代码的异步处理变得简单化。由于Continuations允许显式地挂起和重用代码，因此可以采用如下方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public <span class="keyword">static</span> <span class="keyword">void</span> computeSomething() &#123;</div><div class="line">    <span class="built_in">Promise</span>&lt;<span class="built_in">String</span>&gt; delayedResult = veryLongComputation(…);</div><div class="line">    <span class="built_in">String</span> result = <span class="keyword">await</span>(delayedResult);</div><div class="line">    render(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>事实上，这段代码会分为两步执行，并先后占用两个线程，但对于应用程序的代码却是透明的。以下是基于Continuations实现的循环：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loopWithoutBlocking</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">10</span>; i++) &#123; </div><div class="line">         Logger.info(i);</div><div class="line">         <span class="keyword">await</span>(<span class="string">"1s"</span>);</div><div class="line">    &#125;</div><div class="line">    renderText(<span class="string">"Loop finished"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述示例中，假设Play在DEV模式下运行（只占用一个线程），但仍可以同时处理多个请求。<br>Cotinuations主要通过使用控制器调用await()方法实现，该方法接收两种不同类型的参数（事实上有6种重载的方法，但是主要应用场景为2种）。</p>
<p>第一种：采用timeout的方式来调用await()方法，参数类型可以为毫秒，或者为字符串类型的字面表达式（例如1s代表一秒钟）。<br>第二种：采用Future对象的方式来调用，并且通常情况下会使用Play的Promise(定义在lib.F中，实现了java Future类)。当Promise完成后会返回并继续执行其余的处理。值得注意的是，Promise中可以触发多个事件，比如waitAny()方法参数中包含多个事件，当完成了其中任何一个，该Promise便能够返回并继续执行。</p>
<p>因此，上述的两种方式都会导致在未来某个时间点触发事件。第一种为预先指定，而第二种需要根据Promise完成的时间。</p>
<p>Play引入Cotinuations，使得编写同类事件结构的代码更加简单：</p>
<p>//相关处理A<br>await(timeout or promise);//等待promise执行完毕<br>//相关处理B<br>在等待处理的过程中，服务器将HTTP线程释放出来，因此Play能够并发处理更多的请求，而且非常高效。当timeout时间到达或者Promise执行完毕，后续的代码会继续执行，并且不需要开发者编写任何与线程唤起相关的方法。</p>
<p>使用timeout的方式来调用await()方法：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useTimeout</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">10</span>; i++) &#123; </div><div class="line">         Logger.info(i);</div><div class="line">         <span class="keyword">await</span>(<span class="string">"1s"</span>);</div><div class="line">    &#125;</div><div class="line">    renderText(<span class="string">"Execute finished"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上这段代码在执行过程中，一共释放了10次线程，并且在每秒等待结束后重新唤起。从开发者的角度看，这个处理过程是非常透明的，并且允许直观地构建应用（而不需要担心创建非阻塞应用，因为这些都交由Play进行处理）。</p>
<p>使用Promise的方式来调用await()方法：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void usePromise()&#123;</div><div class="line">        </div><div class="line">    F.Promise&lt;WS.HttpResponse&gt; promise1=WS.url(<span class="string">"http://domain1.com"</span>).getAsync()<span class="comment">;</span></div><div class="line">    F.Promise&lt;WS.HttpResponse&gt; promise2=WS.url(<span class="string">"http://domain2.com"</span>).getAsync()<span class="comment">;</span></div><div class="line">    F.Promise&lt;List&lt;WS.HttpResponse&gt;&gt; promises = F.Promise.<span class="keyword">waitAll(promise1, </span>promise2)<span class="comment">;</span></div><div class="line">    await(promises)<span class="comment">;</span></div><div class="line">    renderText(<span class="string">"Execute finished"</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码使用了lib.F中的waitAll()方法，需要等待promise1和promise2都处理完成后，才能够继续执行后续处理。类似地，Play还提供了waitAny()，waitEither()等方法。<br>8.2HTTP流式响应<br> 由于Play提供在非阻塞的情况下轮询处理请求的功能，读者可能会有这样的设想：服务器端能否实现只要生成了一部分可用的结果数据就马上发送给浏览器。在Play中实现这个功能完全没有问题，而实现的关键就是以Content-Type:Chunked作为HTTP的响应类型。它允许将HTTP响应分成不同的块(chunk)分批发送，只要这些分块一被发出，浏览器立马就能接收到。以下是使用await()方法和Continuations的实现：<br> <figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateLargeCSV</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    CSVGenerator generator = <span class="keyword">new</span> CSVGenerator();</div><div class="line">    response.contentType = <span class="string">"text/csv"</span>;</div><div class="line">    <span class="keyword">while</span>(generator.hasMoreData()) &#123;</div><div class="line">          String someCsvData = <span class="keyword">await</span>(generator.nextDataChunk());</div><div class="line">          response.writeChunk(someCsvData);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然生成这个CSV文件需要花费1个小时，但是Play能够实现只使用一个线程同时处理好几个请求，并且一旦生成可用的数据后就马上发送给客户端。<br>8.3使用WebSocket<br>8.3.1 WebSocket介绍#</p>
<p>WebSocket的目标是通过在浏览器和应用程序之间建立一条通信的频道，实现两者的双向通信。在Play中的WebSocket实现如下：<br>在浏览器端，可以使用“ws://” URL方式建立socket连接：</p>
<p>new WebSocket(“ws://localhost:9000/helloSocket?name=Guillaume”)<br>服务器端配置对应的WebSocket路由规则：<br>WS   /helloSocket            MyWebSocket.hello<br>MyWebSocket是自定义的WebSocket控制器，继承于WebSocketController。WebSocket控制器和标准的HTTP控制器有些类似，但两者在概念上有所区别：<br>WebSocket控制器只有request对象，没有response对象。<br>WebSocket控制器可以访问session，但访问权限是只读的。<br>WebSocket控制器没有renderArgs，routeArgs以及flash作用域。<br>WebSocket控制器只能从路由模式或者以查询字符串的形式来读取参数。<br>WebSocket控制器拥有inbound和outbound两种通信频道。</p>
<p>当客户端(即浏览器)通过ws://localhost:9000/helloSocket 建立socket连接时，Play会调用MyWebSocket控制器中的hello Action方法，一旦MyWebSocket.hello方法结束，该socket连接就会自动关闭：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyWebSocket</span> <span class="keyword">extends</span> <span class="title">WebSocketController</span> </span>&#123;</div><div class="line"> </div><div class="line">    public static void hello(<span class="type">String</span> name) &#123;</div><div class="line">        outbound.send(<span class="string">"Hello %s!"</span>, name);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>针对上述例子，如果客户端建立了socket连接，就会收到“Hello Guillaume”消息，之后Play将socket连接关闭。<br>当然，大部分情况下并不需要急于将socket连接关闭，可以使用await()方法进行一些适当的扩展。以下程序使用了Continuations，使服务器具有应答功能：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyWebSocket</span> <span class="keyword">extends</span> <span class="title">WebSocketController</span> </span>&#123;</div><div class="line"> </div><div class="line">    public static void echo() &#123;</div><div class="line">        <span class="keyword">while</span>(inbound.isOpen()) &#123;</div><div class="line">             <span class="type">WebSocketEvent</span> e = await(inbound.nextEvent());</div><div class="line">             <span class="keyword">if</span>(e instanceof <span class="type">WebSocketFrame</span>) &#123;</div><div class="line">                  <span class="type">WebSocketFrame</span> frame = (<span class="type">WebSocketFrame</span>)e;</div><div class="line">                  <span class="keyword">if</span>(!e.isBinary) &#123;</div><div class="line">                      <span class="keyword">if</span>(frame.textData.equals(<span class="string">"quit"</span>)) &#123;</div><div class="line">                          outbound.send(<span class="string">"Bye!"</span>);</div><div class="line">                          disconnect();</div><div class="line">                      &#125; <span class="keyword">else</span> &#123;</div><div class="line">                          outbound.send(<span class="string">"Echo: %s"</span>, frame.textData);</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">if</span>(e instanceof <span class="type">WebSocketClose</span>) &#123;</div><div class="line">                 <span class="type">Logger</span>.info(<span class="string">"Socket closed!"</span>);</div><div class="line">             &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述例子用了大量的if嵌套语句，书写起来不仅乏味，而且容易出错，这并不是优雅的Java代码。处理如此简单的例子都需要编写复杂的嵌套语句，更何况那些结合了一些数据流，甚至拥有不同事件类型的应用，就会变得异常难以维护。这里介绍一种简洁的书写方式，其中的方法封装在play.libs.F库中。下面对具有应答功能的代码进行重构：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span>(inbound.isOpen()) &#123;</div><div class="line">         WebSocketEvent e = await(inbound.nextEvent());</div><div class="line">         </div><div class="line">         <span class="keyword">for</span>(String quit: TextFrame.and(Equals(<span class="string">"quit"</span>)).match(e)) &#123;</div><div class="line">             outbound.send(<span class="string">"Bye!"</span>);</div><div class="line">             disconnect();</div><div class="line">         &#125;</div><div class="line"> </div><div class="line">         <span class="keyword">for</span>(String msg: TextFrame.match(e)) &#123;</div><div class="line">             outbound.send(<span class="string">"Echo: %s"</span>, frame.textData);</div><div class="line">         &#125;</div><div class="line">         </div><div class="line">         <span class="keyword">for</span>(WebSocketClose closed: SocketClosed.match(e)) &#123;</div><div class="line">             Logger.info(<span class="string">"Socket closed!"</span>);</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>8.3.2 使用WebSocket#</p>
<p>开发WebSocket应用，需要使用支持WebSocket的浏览器（比如Chrome）。Firefox和Opera出于安全考虑，无法使用WebSocket协议。与长时间处理的方法不同，WebSocket中的方法需要在预先定义的时间间隔执行针对模型更新的数据库检查，从而触发事件。WebSocket的理念是保持连接状态，等待事件的触发，然后将事件广播给每个需要的用户。因此在Play中实现WebSocket的最佳方式是使用存储在服务器端的状态对象。虽然这样做有点违背无状态(stateless)以及RESTful风格的理念，但这应该是使用WebSocket的最佳实践。在设计WebSocket应用时，开发者需要根据自己的实际情况对代码做进一步的优化：</p>
<p>下面将演示如何创建WebSocket应用。使用play new命令创建新的应用，名称为websocket：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Play<span class="built_in"> new </span>websocket</div><div class="line">      在app/models/目录中创建StatefulModel.java：</div><div class="line"></div><div class="line">package models;</div><div class="line"></div><div class="line">import play.libs.F;</div><div class="line"><span class="keyword"></span></div><div class="line">public class StatefulModel &#123;</div><div class="line">  <span class="keyword"> public</span><span class="keyword"> static</span> StatefulModel<span class="built_in"> instance </span>=<span class="built_in"> new </span>StatefulModel();</div><div class="line">  <span class="keyword"> public</span><span class="keyword"> final</span> F.EventStream event =<span class="built_in"> new </span>F.EventStream();</div><div class="line"></div><div class="line">  <span class="keyword"> private</span> StatefulModel() &#123; &#125;</div><div class="line">&#125;</div><div class="line">StatefulModel非常简单，由以下几个部分组成：</div></pre></td></tr></table></figure></p>
<p>私有的构造方法StatefulModel()。<br>单例的静态实例化对象（单例模式），这意味着服务器端只允许存在一个StatefulModel的实例。<br>EventStream对象，是WebSocket在Play中实现的最核心部分，它允许发布事件来通知所有等待监听的用户。</p>
<p>在这个例子当中，使用了标准的EventStream来访问当前的事件。Play同时提供了ArchiveEventStream（读者可以在samples-and-tests目录中查看Play提供的chat应用示例），可以获取所有可用的信息。打开app/controllers/Application.java文件，添加如下代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> controllers;</div><div class="line"></div><div class="line"><span class="keyword">import</span> play.mvc.*;</div><div class="line"><span class="keyword">import</span> models.*;</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</div><div class="line"></div><div class="line">   public static void index() &#123;</div><div class="line">      render();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static <span class="class"><span class="keyword">class</span> <span class="title">WebSocket</span> <span class="keyword">extends</span> <span class="title">WebSocketController</span> </span>&#123;</div><div class="line"></div><div class="line">      public static void listen() &#123;</div><div class="line">         <span class="keyword">while</span>(inbound.isOpen()) &#123;</div><div class="line">            <span class="type">String</span> event = await(<span class="type">StatefulModel</span>.instance.event.nextEvent());</div><div class="line">            outbound.send(event);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Application控制器中增加了继承WebSocketController的静态类。WebSocketController与标准的控制器有所不同：前者是基于inbound/outbound模式，而后者是面向request/response模式的。上述代码的业务逻辑非常简单，只是通过while循环来检查inbound是否处于打开状态（即WebSocket处于连接状态），接着调用nextEvent()方法来等待事件的触发。</p>
<p>早期的Play版本并没有await()方法。await()方法的作用是挂起HTTP请求，释放当前资源让框架以便继续处理其他的请求。直到有新的事件添加到StatefulModel中，程序会从之前离开的地方继续执行，而不是重新开始。</p>
<p>代码将数据从事件发送到outbound，最终返回到浏览器。那么浏览器需要如何处理这些数据呢？创建views/application/index.html模板：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#&#123;extends 'main.html' /&#125;</div><div class="line">#&#123;set title:'Home' /&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"socketout"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="comment">// Create a socket</span></div><div class="line">    <span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'@@&#123;Application.WebSocket.listen&#125;'</span>)</div><div class="line"></div><div class="line">    <span class="comment">// Message received on the socket</span></div><div class="line">    socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        $(<span class="string">'#socketout'</span>).append(event.data+<span class="string">"&lt;br /&gt;"</span>);</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在模版中，仅仅使用div来显示WebSocket发送的数据。JavaScript的内容为：</p>
<p>创建WebSocket连接。<br>将获得的数据添加到div中。<br>在为自定义的WebSocket增加事件之前，先定义好路由：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WS      /socket                            Application<span class="selector-class">.WebSocket</span><span class="selector-class">.listen</span></div></pre></td></tr></table></figure></p>
<p>需要注意的是，这里使用WS作为HTTP请求类型来描述WebSocket请求，剩下的部分和之前一样配置。现在WebSocket已经可以运行了，但是这时候开启应用，打开浏览器看到的是空白页面，这是因为服务器并没有返回数据给浏览器，所以最后需要做的是触发事件。创建异步Job，在EventStream中增加一些消息。</p>
<p>在app目录下新建jobs包，然后创建Startup.java文件：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> job;</div><div class="line"></div><div class="line"><span class="keyword">import</span> play.jobs.*;</div><div class="line"><span class="keyword">import</span> models.<span class="type">StatefulModel</span>;</div><div class="line"></div><div class="line"><span class="meta">@OnApplicationStart</span>(async = <span class="literal">true</span>)</div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Startup</span> <span class="keyword">extends</span> <span class="title">Job</span> </span>&#123;</div><div class="line">   public void doJob() <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</div><div class="line">      int i = <span class="number">0</span>;</div><div class="line"></div><div class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">         i++;</div><div class="line">         <span class="type">Thread</span>.sleep(<span class="number">1000</span>);</div><div class="line">         <span class="type">StatefulModel</span>.instance.event.publish(<span class="string">"On step "</span> + i);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个Job会在应用启动的时候执行，并一直循环下去，直到应用停止。每次迭代的时候暂停1秒钟，然后为StatefulModel的EventStream发送一个事件。</p>
<p>开启应用，访问<a href="http://localhost:9000/查看效果，当打开页面的时候，可以发现事件会广播到每个监听的浏览器：" target="_blank" rel="external">http://localhost:9000/查看效果，当打开页面的时候，可以发现事件会广播到每个监听的浏览器：</a></p>
<p>图片资源/websocket.jpg<br>8.4本章小结<br>本章主要介绍了如何在Play上进行HTTP异步编程。Play为我们提供了良好的异步编程实现框架，通过await()方法挂起请求，并在相应的操作完成后回调。此外还提供了HTTP流式响应的支持，使得应用具有更加快速响应的用户体验，即一有可用的数据就返回给客户端，而不是等待所有数据准备就绪后再响应。有了这些，我们可以很快速地编写出基于异步处理的应用，比如聊天室。本章最后还介绍了如何利用Play进行WebSocket编程。</p>
</div><div class="tags"><a href="/tags/play/">play</a></div><div class="post-nav"><a href="/2016/11/24/第七章-Job异步处理/" class="next">第七章 Job异步处理</a></div><div data-thread-key="2016/11/24/第八章-HTTP异步编程/" data-title="第八章 HTTP异步编程" data-url="http://lisxweb.github.io/2016/11/24/第八章-HTTP异步编程/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/11/24/第八章-HTTP异步编程/" data-title="第八章 HTTP异步编程" data-url="http://lisxweb.github.io/2016/11/24/第八章-HTTP异步编程/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux服务器/">Linux服务器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MAC实用/">MAC实用</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/play-framework框架/">play framework框架</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Linux服务器/" style="font-size: 15px;">Linux服务器</a> <a href="/tags/MAC-Eclipse-快捷键/" style="font-size: 15px;">MAC Eclipse 快捷键</a> <a href="/tags/play/" style="font-size: 15px;">play</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/11/24/第八章-HTTP异步编程/">第八章 HTTP异步编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/24/第七章-Job异步处理/">第七章 Job异步处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/24/第六章-域模型/">第六章 域模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/24/第五章-模板引擎/">第五章 模板引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/23/第四章-控制层/">第四章 控制层</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/22/第三章-路由语法/">第三章 路由语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/整理MAC下Eclipse的常用快捷键/">整理MAC下Eclipse的常用快捷键</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/Linux服务器增量备份脚步/">Linux服务器增量备份脚本</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/第二章-基础概念/">第二章 基础概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/第一章-绪论/">第一章 绪论</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-commt"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:zhenggchaoo@gmail.com" target="_blank" class="fa fa-email"> </a><a href="http://weibo.com/zhengchaooo" target="_blank" class="fa fa-weibo"></a><a href="https://github.com/chaooo" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">lisxweb</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script>var duoshuoQuery = {short_name:'lisx'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    document.getElementsByTagName('body')[0].appendChild(ds);
})();
</script><script type="text/javascript" src="/js/search.json.js?v=1.0.0"></script></body></html>