<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人日记 nodejs学习。"><meta name="baidu-site-verification" content="7tp9tihrLG"><title>第四章 控制层 | 秋过冬漫长天亮中</title><link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.0.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第四章 控制层</h1><a id="logo" href="/.">秋过冬漫长天亮中</a><p class="description">没有比脚更长的路，走过去，前面是个天！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">第四章 控制层</h1><div class="post-meta">Nov 23, 2016<span> | </span><span class="category"><a href="/categories/play-framework框架/">play framework框架</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/11/23/第四章-控制层/" href="/2016/11/23/第四章-控制层/#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div></div></div><div class="post-content"><p>业务逻辑通常在域模型层中进行管理，而客户端（通常为浏览器）无法直接调用业务代码。因此Play采用将域对象的方法开放为URI资源的形式，实现功能代码的调用。</p>
<p>客户端使用HTTP协议中提供的统一API来操作资源，并隐式地调用底层的业务逻辑。但是这种资源与域对象模型之间的映射并不是双向的：因为其粒度可以被划分为不同的级别，而且有些资源根本就是虚拟的或者被重命名过的。</p>
<p>这正是控制器所起的作用：提供域模型对象与传输层事件(事件驱动)之间的映射关系。由于模型层和控制器都是纯Java编写的，之间的访问和调用将变得非常容易。控制器是面向过程的，并且采用request/response模式(这一点与HTTP接口类似)。基于以上几点，控制器大大减少了由于HTTP和模型域之间不匹配而造成的阻碍。</p>
<p>注意：<br>对待不同结构的模型，应该采取不同的策略。有些协议允许直接访问域模型对象，非常典型的就有EJB和CORBA等。在这些协议中，均使用RPC（远程过程调用）的设计风格，但是这样的通信方式很难与Web架构相兼容。当然，还有一些其他技术比如SOAP试图通过Web来访问域模型对象，但是SOAP也仅仅是RPC风格协议的一个变种，采用HTTP作为其传输协议。总而言之，这些都不能归属为应用协议。</p>
<p>从根本上讲，Web规范并不是面向对象的，所以需要引入使HTTP与编程语言相适应的层————控制层。</p>
<p>4.1控制层概述<br> Play的控制层位于应用的controllers包中，其中的Java类即为控制器(Controller)。如图4.1所示，Application.java和MyController.java都属于控制层。</p>
<p>图片资源/controller.png</p>
<p>(图4.1 控制器为controllers包中的Java类)</p>
<p>控制器需要继承play.mvc.Controller：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package controllers;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> models.<span class="built_in">Client</span>;</div><div class="line"><span class="keyword">import</span> play.mvc.Controller;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Clients extends Controller &#123;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> show(Long id) &#123;</div><div class="line">        <span class="built_in">Client</span> client = <span class="built_in">Client</span>.findById(id);</div><div class="line">        render(client);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">delete</span>(Long id) &#123;</div><div class="line">        <span class="built_in">Client</span> client = <span class="built_in">Client</span>.findById(id);</div><div class="line">        client.<span class="keyword">delete</span>();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在控制器中，每个以public static声明，返回值为void的方法称为Action。Action的方法声明如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action_name</span>(<span class="params"><span class="keyword">params</span>…</span>)</span>;</div></pre></td></tr></table></figure></p>
<p>Play会自动将HTTP请求参数转化为与之相匹配的Action方法参数，这部分内容会在后面的获取HTTP参数小节进行详细讲解。通常情况下，Action方法无需返回任何值，以调用结果方法来终止执行。在上述例子中，render(…)方法就是用来渲染模板的结果方法。</p>
<p>4.2获取HTTP参数<br> HTTP请求中往往包含各种参数，这些参数的传递形式如下：</p>
<p>URI路径：在路径/clients/1541中，1541是URI的动态部分。<br>查询字符串：clients?id=1541。<br>请求体：如果请求是来自HTML的表单提交（GET或者POST），那么请求体包含的是表单数据(采用x-www-urlform-encoded作为编码格式)。</p>
<p>针对以上几种情况，Play会自动提取这些HTTP参数并将他们保存在Map<string,string>类型的变量中，以参数名作为Map的key。这些参数名分别来自于：</string,string></p>
<p>URI中动态部分的名称（在routes文件中定义）。<br>查询字符串中“名称/值”对中的名称部分 。<br>采用x-www-urlform-encoded编码的表单数据的参数名。</p>
<p>4.2.1 使用Map参数#</p>
<p>HTTP请求中参数对象(params)在任何控制器中都是可访问的（该实现在play.mvc.Controller超类中定义），它包含了当前所有HTTP请求的参数，并且可以通过get()方法得到，具体如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    String id=<span class="keyword">params</span>.<span class="keyword">get</span>(<span class="string">"id"</span>);</div><div class="line">    String[] names=<span class="keyword">params</span>.getAll(<span class="string">"name"</span>);</div><div class="line">&#125;</div><div class="line">这些参数也可以进行类型转换：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    Long id=<span class="keyword">params</span>.<span class="keyword">get</span>(<span class="string">"id"</span>,Long.class);</div><div class="line">&#125;</div><div class="line">本节将推荐一种更好的解决方案。Play框架提供了自动将Action声明的参数与HTTP参数自动匹配的功能（只需要保持Action方法的参数名和HTTP参数名一致即可）:</div><div class="line"></div><div class="line">/clients?id=<span class="number">1541</span> </div><div class="line">Action方法可以在声明中以id作为参数，以此匹配HTTP中变量名为id的参数：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params">String id</span>)</span>&#123;</div><div class="line">    System.<span class="keyword">out</span>.println(id);</div><div class="line">&#125;</div><div class="line">当然，也可以使用其他Java参数类型，而不仅仅是String。在下面的例子中框架会自动将参数转换为正确的数据类型：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params">Long id</span>)</span>&#123;</div><div class="line">    System.<span class="keyword">out</span>.println(id);</div><div class="line">&#125;</div><div class="line">如果参数含有多个值，那么可以定义数组参数，具体如下：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params">Long[] id</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(Long anId:id)&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(anId);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">参数甚至可以是List类型：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params">List&lt;Long&gt; id</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(Long anId:id)&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(anId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：<br>如果Action与HTTP之间的参数无法匹配，Play会将该参数设置为默认值（通常情况下对象类型为null，原始数据类型为0）。如果参数可以匹配但不能正确进行数据转换，那么Play会先生成错误并添加到验证器的error对象集合中，然后将参数设置为默认值。</p>
<p>4.2.2 高级HTTP绑定#</p>
<p>简单类型</p>
<p>Play可以实现所有Java原生的简单数据类型的自动转换，主要包括：int，long，boolean，char，byte，float，double，Integer，Long，Boolean，Char，String，Float，Double。</p>
<p>日期类型</p>
<p>如果HTTP参数字符串符合以下几种数据格式，框架能够自动将其转换为日期类型：</p>
<p>yyyy-MM-dd’T’hh:mm:ss’Z’ // ISO8601 + timezone<br>yyyy-MM-dd’T’hh:mm:ss” // ISO8601<br>yyyy-MM-dd<br>yyyyMMdd’T’hhmmss<br>yyyyMMddhhmmss<br>dd’/‘MM’/‘yyyy<br>dd-MM-yyyy<br>ddMMyyyy<br>MMddyy<br>MM-dd-yy<br>MM’/‘dd’/‘yy<br>而且还能通过@As注解，指定特定格式的日期，例如：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">archives?<span class="keyword">from</span>=<span class="number">21</span>/<span class="number">12</span>/<span class="number">1980</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">articlesSince</span>(<span class="params">@As(<span class="string">"dd/MM/yyyy"</span></span>) Date <span class="keyword">from</span>) </span>&#123;</div><div class="line">    List&lt;Article&gt; articles = Article.findBy(<span class="string">"date &gt;= ?"</span>, <span class="keyword">from</span>);</div><div class="line">    render(articles);</div><div class="line">&#125;</div><div class="line">也可以根据不同地区的语言习惯对日期的格式做进一步的优化，具体如下：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">articlesSince</span>(<span class="params">@As(lang=&#123;<span class="string">"fr,de"</span>,<span class="string">"*"</span>&#125;, </span></span></div><div class="line">        <span class="keyword">value</span>=&#123;<span class="string">"dd-MM-yyyy"</span>,<span class="string">"MM-dd-yyyy"</span>&#125;) Date <span class="keyword">from</span>) &#123;</div><div class="line">    List&lt;Article&gt; articles = Article.findBy(<span class="string">"date &gt;= ?"</span>, <span class="keyword">from</span>);</div><div class="line">    render(articles);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，对于法语和德语的日期格式是dd-MM-yyyy，其他语言的日期格式是MM-dd-yyyy。语言值可以通过逗号隔开，且需要与参数的个数相匹配。</p>
<p>如果没有使用@As注解来指定，Play会采用框架默认的日期格式。为了使默认的日期格式能够正常工作，按照以下方式编辑application.conf文件：</p>
<p>date.format=yyyy-MM-dd<br>在application.conf文件中设置默认的日期格式之后，就可以通过${date.format()}方法对模板中的日期进行格式化操作了。</p>
<p>日历类型</p>
<p>日历类型和日期类型非常相像，当然Play会根据本地化选择默认的日历类型。读者也可以通过@Bind注解来使用自定义的日历类型。</p>
<p>文件类型</p>
<p>在Play中处理文件上传是件非常容易的事情，首先通过multipart/form-data编码的请求将文件发送到服务器，然后使用java.io.File类型提取文件对象：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> create(<span class="keyword">String</span> comment, <span class="built_in">File</span> attachment) &#123;</div><div class="line">    <span class="keyword">String</span> s3Key = S3.post(attachment);</div><div class="line">    Document doc = <span class="keyword">new</span> Document(comment, s3Key);</div><div class="line">    doc.save();</div><div class="line">    show(doc.id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>新创建文件的名称与原始文件一致，保存在应用的临时文件下（Application_name/tmp）。在实际开发中，需要将其拷贝到安全的目录，否则在请求结束后会丢失。</p>
<p>数组和集合类型</p>
<p>所有Java支持的数据类型都可以通过数组或者集合的形式来获取。数组形式：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public static void <span class="keyword">show</span>(<span class="keyword">Long</span>[] <span class="keyword">id</span>)&#123;</div><div class="line">        ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">List</span>形式：</div><div class="line"><span class="keyword">public</span> staic <span class="built_in">void</span> <span class="keyword">show</span>(<span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; <span class="keyword">id</span>)&#123;</div><div class="line">        ...</div><div class="line">&#125;</div><div class="line">集合形式：</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="keyword">show</span>(<span class="keyword">Set</span>&lt;<span class="keyword">Long</span>&gt; <span class="keyword">id</span>)&#123;</div><div class="line">        ...</div><div class="line">&#125;</div><div class="line">Play还可以处理<span class="keyword">Map</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;映射形式：</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="keyword">show</span>(<span class="keyword">Map</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="keyword">client</span>) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例如下面的查询字符串会转化为带有两个元素的map类型，第一个元素key值为name，value为John；第二个元素key值为phone，value为111-1111, 222-2222。：<br>?user.name=John&amp;user.phone=111-1111&amp;user.phone=222-2222</p>
<p>POJO对象绑定</p>
<p>Play使用同名约束规则（即HTTP参数名必须与模型类中的属性名一致），自动绑定模型类：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> create(Client <span class="keyword">client</span>)&#123;</div><div class="line">    <span class="keyword">client</span>.save();</div><div class="line">    show(<span class="keyword">client</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下的查询字符串可以通过上例的Action创建client：</p>
<p>?client.name=Zenexity&amp;client.email=contact@zenexity.fr<br>框架通过Action创建Client的实例，并将HTTP参数解析为该实例的属性。如果出现参数无法解析或者类型不匹配的情况，会自动忽略。<br>参数绑定是递归执行的，这意味着可以深入到关联对象：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">?client.name=Zenexity</div><div class="line">&amp;client.address.street=<span class="number">64</span>+rue+taitbout</div><div class="line">&amp;client.address.zip=<span class="number">75009</span></div><div class="line">&amp;client.address.country=France</div><div class="line">Play的参数绑定提供数组的支持，可以将对象id作为映射规则，更新一组模型对象。假设Client模型有一组声明为List&lt;Customer&gt;的customers属性，那么更新该属性需要使用如下查询字符串：</div><div class="line"></div><div class="line">?client.customers[<span class="number">0</span>].id=<span class="number">123</span></div><div class="line">&amp;client.customers[<span class="number">1</span>].id=<span class="number">456</span></div><div class="line">&amp;client.customers[<span class="number">2</span>].id=<span class="number">789</span></div></pre></td></tr></table></figure></p>
<p>4.2.3 JPA对象绑定#</p>
<p>通过HTTP参数还可以实现JPA对象的自动绑定。Play会识别HTTP请求中提供的参数user.id，自动与数据库中User实例的id进行匹配。一旦匹配成功，HTTP请求中的其他User属性参数可以直接更新到数据库相应的User记录中：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void save(<span class="keyword">User</span> <span class="keyword">user</span>)&#123;</div><div class="line">    <span class="keyword">user</span>.save();</div><div class="line">&#125;</div><div class="line">和POJO映射类似，可以使用JPA绑定来更改对象，但需要注意的是必须为每个需要更改的对象提供id：</div><div class="line"></div><div class="line"><span class="keyword">user</span>.id = <span class="number">1</span></div><div class="line">&amp;<span class="keyword">user</span>.name=morten</div><div class="line">&amp;<span class="keyword">user</span>.address.id=<span class="number">34</span></div><div class="line">&amp;<span class="keyword">user</span>.address.street=MyStreet</div></pre></td></tr></table></figure></p>
<p>4.2.4 自定义绑定#</p>
<p>绑定机制支持自定义功能，可以按照读者的需求，自定义参数绑定的规则。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@play</span>.data.binding.As</div><div class="line"></div><div class="line"><span class="variable">@play</span>.data.binding.As注解可以依据配置提供绑定的支持。下例使用DateBinder指定日期的数据格式：</div><div class="line"></div><div class="line">public static void update(<span class="variable">@As</span>(<span class="string">"dd/MM/yyyy"</span>) Date updatedAt) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="variable">@As</span>注解还具有国际化支持，可以为每个本地化提供专门的注解：</div><div class="line"></div><div class="line">public static void update(</div><div class="line">        <span class="variable">@As</span>(</div><div class="line">            lang=&#123;<span class="string">"fr,de"</span>,<span class="string">"en"</span>,<span class="string">"*"</span>&#125;,</div><div class="line">            value=&#123;<span class="string">"dd/MM/yyyy"</span>,<span class="string">"dd-MM-yyyy"</span>,<span class="string">"MM-dd-yy"</span>&#125;</div><div class="line">        )</div><div class="line">        Date updatedAt</div><div class="line">    ) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>@As注解可以和所有支持它的绑定一起工作，包括用户自定义的绑定。以下是使用ListBinder的例子：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">update</span>(<span class="variable">@As</span>(<span class="string">","</span>) List&lt;String&gt; items) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上例中的绑定使用逗号将字符串分隔成List。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@play</span>.data.binding.NoBinding</div><div class="line"></div><div class="line"><span class="variable">@play</span>.data.binding.NoBinding注解允许对不需要绑定的属性进行标记，以此来解决潜在的安全问题。比如：</div><div class="line"></div><div class="line"><span class="comment">//User为Model类</span></div><div class="line">public class User extends Model &#123;</div><div class="line">    <span class="variable">@NoBinding</span>(<span class="string">"profile"</span>) public boolean isAdmin;</div><div class="line">    <span class="variable">@As</span>(<span class="string">"dd, MM yyyy"</span>) Date birthDate;</div><div class="line">    <span class="selector-tag">public</span> <span class="selector-tag">String</span> <span class="selector-tag">name</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//editProfile为Action方法</span></div><div class="line"><span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">editProfile</span>(<span class="variable">@As</span>(<span class="string">"profile"</span>) User user) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上述例子中，user对象的isAdmin属性始终不会被editProfile方法(Action)所修改，即使有恶意用户伪造POST表单提交user.isAdmin=true信息，也不能修改user的isAdmin权限。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">play.data.binding.TypeBinder</div><div class="line"></div><div class="line"><span class="meta">@As</span>注解还提供完全自定义绑定的功能。自定义绑定必须是TypeBinder类的实现：</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyCustomStringBinder</span> <span class="keyword">implements</span> <span class="title">TypeBinder</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line"> </div><div class="line">    public <span class="built_in">Object</span> bind(<span class="built_in">String</span> name, Annotation[] anns, <span class="built_in">String</span> value, </div><div class="line">    Class clazz) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"!!"</span> + value + <span class="string">"!!"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">定义完成后，就可以在任何Action中使用它：</div><div class="line">public <span class="keyword">static</span> <span class="keyword">void</span> anyAction(<span class="meta">@As</span>(binder=MyCustomStringBinder.<span class="keyword">class</span>) <span class="built_in">String</span> name) &#123;</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>@play.data.binding.Global</p>
<p>Play中还可以自定义全局Global绑定。以下是为java.awt.Point类定义绑定的例子：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Global</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PointBinder</span> <span class="keyword">implements</span> <span class="title">TypeBinder</span>&lt;<span class="title">Point</span>&gt; </span>&#123;</div><div class="line"> </div><div class="line">    public <span class="built_in">Object</span> bind(<span class="built_in">String</span> name, Annotation[] anns, <span class="built_in">String</span> value, </div><div class="line">    Class <span class="class"><span class="keyword">class</span>) </span>&#123;</div><div class="line">        <span class="built_in">String</span>[] values = value.split(<span class="string">","</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(</div><div class="line">            Integer.parseInt(values[<span class="number">0</span>]),</div><div class="line">            Integer.parseInt(values[<span class="number">1</span>])</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此外部模块很容易通过自定义绑定来提供可重用的类型转换组件。</p>
<p>4.3结果返回<br> Action方法需要对客户端作出HTTP响应，最简单的方法就是发送结果对象。当对象发送后，常规的执行流程就会中断。以下面这段代码为例，最后一句System.out.println的输出不会被执行:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> show(Long id) &#123;</div><div class="line">    <span class="built_in">Client</span> client = <span class="built_in">Client</span>.findById(id);</div><div class="line">    render(client);</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"This message will never be displayed !"</span>);</div><div class="line">&#125;</div><div class="line">render(…)</div></pre></td></tr></table></figure></p>
<p>方法向模板发送client对象，之后的其他语句将不会执行，所以在控制台中，并不会打印出“This message will never be displayed !”。</p>
<p>4.3.1 返回文本内容#</p>
<p>renderText(…)方法直接将文本内容写到底层HTTP响应中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countUnreadMessages</span><span class="params">()</span></span>&#123;</div><div class="line">    Integer unreadMessages=MessagesBos.countUnreadMessage();</div><div class="line">    renderText(unreadMessages);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以通过Java标准的格式化语法对输出的文本进行处理：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countUnreadMessages</span><span class="params">()</span></span>&#123;</div><div class="line">    Integer unreadMessages=MessagesBox.countUnreadMessages();</div><div class="line">    renderText(<span class="string">"There are %s unread messages"</span>,unreadMessages);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.3.2 返回JSON字符串#</p>
<p>越来越多的应用使用JSON作为数据格式进行交互，Play对此进行了很好的封装，只需要使用renderJSON(…)方法就可以轻松地返回JSON字符串。在使用renderJSON(…)方法时，Play会自动将服务器返回的响应的content type值设置为application/json，并且将renderJSON(…)方法中的参数以JSON格式返回。<br>在使用renderJSON(…)方法时，可以输入字符串格式的参数，自行指定JSON返回的内容。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countUnreadMessages</span><span class="params">()</span> </span>&#123;</div><div class="line">    Integer unreadMessages = MessagesBox.countUnreadMessages();</div><div class="line">    renderJSON(<span class="string">"&#123;\"messages\": "</span> + unreadMessages +<span class="string">"&#125;"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上范例在使用renderJSON(…)方法时，传入了拼接成JSON格式的字符串参数。Play框架会对其进行自动设置，改变content type的值为application/json。</p>
<p>当然，renderJSON(…)方法的功能并不只有这些。因为大部分的应用需求，都会要求服务端返回比较复杂的JSON格式，如果都采用字符串拼接的方式组成JSON内容，就太不人性化了。renderJSON(…)的输入参数还可以是复杂的对象，如果采用这种方式使用renderJSON(…)方法，Play在执行renderJSON(…)时，底层会先调用GsonBuilder将对象参数进行序列化，之后再将复杂的对象以JSON的格式返回给请求。这样开发者就可以完全透明地使用renderJSON(…)方法，不需要做其他的任何操作了，以下代码范例将会展示renderJSON(…)的这个功能。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUnreadMessages</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Message&gt; unreadMessages = MessagesBox.unreadMessages();</div><div class="line">    renderJSON(unreadMessages);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.3.3 返回XML字符串#</p>
<p>与使用renderJSON(…)方法返回JSON内容类似，如果用户希望以XML格式对内容进行渲染，可以在Controller控制器中直接使用renderXml(…)方法。 使用renderXml(…)方法时，Play会自动将服务器返回的响应的content type值设置为application/xml。<br>在使用renderXml(…)方法时，可以输入字符串格式的参数，自行指定XML返回的内容。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countUnreadMessages</span><span class="params">()</span> </span>&#123;</div><div class="line">    Integer unreadMessages = MessagesBox.countUnreadMessages();</div><div class="line">    renderXml(<span class="string">"&lt;unreadmessages&gt;"</span>+unreadMessages+<span class="string">"&lt;/unreadmessages&gt;"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果希望将复杂的对象以XML格式进行渲染，可以在使用renderXml(…)方法时输入org.w3c.dom.Document格式的对象，或者直接输入POJO对象。以POJO对象作为参数使用renderXml(…)方法时，Play会使用XStream将其进行序列化操作。同样的，这些序列化操作都不需要由开发者去做，全部交给Play就行，开发者需要做的就是按照规范简单地调用renderXml(…)方法即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUnreadMessages</span><span class="params">()</span> </span>&#123;</div><div class="line">    Document unreadMessages = MessagesBox.unreadMessagesXML();</div><div class="line">    renderXml(unreadMessages);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.3.4 返回二进制内容#</p>
<p>Play为开发者提供了renderBinary(…)方法，可以非常方便的返回二进制数据（如存储在服务器里的文件、图片等）给客户端。以下代码范例将会展示如何使用renderBinary(…)方法进行二进制图片的渲染。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">userPhoto</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123; </div><div class="line">   <span class="keyword">final</span> User user = User.findById(id); </div><div class="line">   response.setContentTypeIfNotSet(user.photo.type());</div><div class="line">   java.io.InputStream binaryData = user.photo.get();</div><div class="line">   renderBinary(binaryData);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先，开发者需要建立用于持久化的域模型User，该User模型具有play.db.jpa.Blob类型的属性photo。play.db.jpa.Blob是经过Play封装的特有的属性类型，可以很方便的处理二进制数据。之后，在Controller控制器中使用时，需要调用域模型的findById(…)方法加载持久化的数据，并将图片以二进制数据流InputStream的形式进行渲染。</p>
<p>4.3.5 下载附件功能#</p>
<p>如果开发者希望将存储在服务器端的文件，采用下载的形式渲染给客户端用户，需要对HTTP的header进行设置。通常的做法是通知Web浏览器将二进制响应数据以附件的形式，下载至用户的本地电脑上。在Play中完成这个功能非常简单，只需要在使用renderBinary(…)方法时多传入一个文件名的参数即可。这样做会触发renderBinary(…)的额外功能，提供文件名并设置响应头的Content-Disposition属性。之后二进制文件（包括图片）将会以附件下载的形式，渲染给用户。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static void userPhoto(long id) &#123; </div><div class="line">   final User user = User.findById(id)<span class="comment">; </span></div><div class="line">   response.setContentTypeIfNotSet(user.photo.type())<span class="comment">;</span></div><div class="line">   <span class="keyword">java.io.InputStream </span><span class="keyword">binaryData </span>= user.photo.get()<span class="comment">;</span></div><div class="line">   renderBinary(<span class="keyword">binaryData, </span>user.photoFileName)<span class="comment">; </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.3.6 执行模板#</p>
<p>如果需要响应的内容比较复杂，那么就应该使用模板来进行处理：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Clients</span> <span class="keyword">extends</span> <span class="title">Controller</span></span>&#123;</div><div class="line">    public static void index()&#123;</div><div class="line">        render();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>模板的名称遵从Play的约束规则，默认的模板路径采用控制器和Action的名称相结合的方式来定义，比如在上述例子中，模板对应的路径为：app/views/Clients/index.html。</p>
<p>4.3.7 为模板作用域添加数据#</p>
<p>通常情况下模板文件都需要数据进行显示，可以使用renderArg()方法为模板注入数据：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Clients</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</div><div class="line"> </div><div class="line">    public static void show(<span class="type">Long</span> id) &#123;</div><div class="line">        <span class="type">Client</span> client = <span class="type">Client</span>.findById(id);</div><div class="line">        renderArgs.put(<span class="string">"client"</span>, client);</div><div class="line">        render();    </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在模板执行过程当中，client变量可以被使用：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Client $</span><span class="template-variable">&#123;client.name&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>4.3.8 更简单方式#</p>
<p>这里介绍一种更简单的方式向模板传递数据。直接使用render(…)方法注入模板数据：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> show(Long id)&#123;</div><div class="line">    <span class="built_in">Client</span> client=<span class="built_in">Client</span>.findById(id);</div><div class="line">    render(client);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以该方式进行数据传递，模板中可访问的变量与Java本地变量的名称（也就是render()方法中的参数名）一致。当然也可以同时传递多个参数：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> show(Long id)&#123;</div><div class="line">    <span class="built_in">Client</span> client=<span class="built_in">Client</span>.findById(id);</div><div class="line">    render(id,client);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：<br>render()方法只允许传递本地变量。</p>
<p>4.3.9 指定其他模板进行渲染#</p>
<p>如果读者不希望使用默认的模板进行渲染，那么可以在renderTemplate(…)方法的第一个参数中指定其他自定义的模板路径，例如：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> show(Long id) &#123;</div><div class="line">    <span class="built_in">Client</span> client = <span class="built_in">Client</span>.findById(id);</div><div class="line">    renderTemplate(<span class="string">"Clients/showClient.html"</span>, id, client);    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.3.10 重定向URL#<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">redirect(…)方法产生HTTP重定向响应，可以将请求转发到其他URL:</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">()</span></span>&#123;</div><div class="line">    redirect(<span class="string">"http://www.oopsplay.org"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.3.11 自定义Web编码#</p>
<p>Play推荐开发者使用UTF-8作为应用开发的编码格式，如果不进行任何设置，Play框架默认使用的也就是UTF-8格式。但是具体情况并不总是这么理想，有些特殊的需求可能要求某些响应（response）的格式为ISO-8859-1，或者要求整个应用都必须保持ISO-8859-1编码。</p>
<p>为当前响应设置编码格式</p>
<p>如果需要改变某一个响应（response）的编码格式，可以直接在Controller控制器中进行修改，具体做法如下所示：</p>
<p>response.encoding = “ISO-8859-1”;<br>当开发表单提交功能时，如果开发者希望某一表单提交的内容采用非框架默认使用的编码（即Play框架采用默认的编码格式UTF-8，而该form表单提交的内容希望采用ISO-8859-1编码格式），Play的做法有一些特殊。在书写form表单的HTML代码时，需要对采用何种编码格式进行两次标识。首先需要在<form>标签中添加accept-charset属性（如：accept-charset=”ISO-8859-1”），accept-charset属性会通知浏览器当form表单提交的时候，采用何种编码格式；其次，需要在form表单中添加hidden隐藏域，name属性规定为“<em>charset</em>”，value属性为具体需要的编码格式，这样做的目的是当form提交的时候，可以通知服务端的Play采用何种编码方式，具体范例如下：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;form action=<span class="string">"@&#123;application.index&#125;"</span> method=<span class="string">"<span class="keyword">POST</span>"</span> accept-charset=<span class="string">"ISO-8859-1"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"_charset_"</span> value=<span class="string">"ISO-8859-1"</span>&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></form></p>
<p>定义全局编码格式</p>
<p>通常情况下，整个应用应该保持统一的编码格式。如果开发者需要设置应用全局的编码格式，可以在application.conf配置文件中修改application.web_encoding属性，配置相应的编码。</p>
<p>4.4Action链<br> Play中的Action链与Servlet API中的forward不尽相同。Play的每次HTTP请求只能调用一个Action，如果需要调用其他的Action，那么必须将浏览器重定向到相应的URL。在这种情况下，浏览器的URL始终与正在执行的Action保持对应关系，使得后退、前进、刷新操作更加清晰。</p>
<p>调用控制器中其他Action方法也可以实现重定向，框架会拦截该调用并生成正确的HTTP重定向。具体实现如下：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clients</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> show(Long id) &#123;</div><div class="line">        Client <span class="keyword">client</span> = Client.findById(id);</div><div class="line">        render(<span class="keyword">client</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> create(String name) &#123;</div><div class="line">        Client <span class="keyword">client</span> = <span class="keyword">new</span> Client(name);</div><div class="line">        <span class="keyword">client</span>.save();</div><div class="line">        show(<span class="keyword">client</span>.id);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">      相应的路由规则定义如下：</div><div class="line"></div><div class="line">GET            /clients/&#123;id&#125;                              Clients.show</div><div class="line">POST           /clients                                   Clients.create</div></pre></td></tr></table></figure></p>
<p>按照定义，Action链的生命周期为：<br>浏览器向/clients发送POST请求;<br>路由器调用Clients控制器中的create方法;<br>create方法直接访问show方法;<br>Java调用被拦截，路由器逆向生成带有id参数的URL来调用Clients.show;<br>HTTP响应重定向为：/clients/3132;<br>浏览器地址栏中URL展现为：/clients/3132;</p>
<p>4.5拦截器<br>控制器中可以定义拦截方法（也可称之为拦截器），为控制器及其子类的所有Action提供服务。当所有的Action都需要进行通用的处理时，该功能就显得非常有用：比如验证用户的合法性，加载请求范围内的信息等。</p>
<p>读者在使用时需要注意的是，这些拦截器方法不能定义为public，但必须是static，并通过有效的拦截标记进行注解。</p>
<p>4.5.1 @Before#</p>
<p>使用@Before注解的方法会在每个Action调用之前执行。如创建具有用户合法性检查的拦截器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Before</span></div><div class="line">    static void checkAuthentification() &#123;</div><div class="line">        <span class="keyword">if</span>(session.get(<span class="string">"user"</span>) == <span class="literal">null</span>) login();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static void index() &#123;</div><div class="line">        <span class="type">List</span>&lt;<span class="type">User</span>&gt; users = <span class="type">User</span>.findAll();</div><div class="line">        render(users);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ...</div><div class="line"> </div><div class="line">&#125;</div><div class="line">如果不希望<span class="meta">@Before</span>注解拦截所有的<span class="type">Action</span>方法，那么可以使用unless参数列出需要排除的方法：</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Before</span>(unless=<span class="string">"login"</span>)</div><div class="line">    static void checkAuthentification() &#123;</div><div class="line">        <span class="keyword">if</span>(session.get(<span class="string">"user"</span>) == <span class="literal">null</span>) login();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static void index() &#123;</div><div class="line">        <span class="type">List</span>&lt;<span class="type">User</span>&gt; users = <span class="type">User</span>.findAll();</div><div class="line">        render(users);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ...</div><div class="line"> </div><div class="line">&#125;</div><div class="line">      或者直接使用only参数把需要拦截的方法列举出来：</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Before</span>(only=&#123;<span class="string">"login"</span>,<span class="string">"logout"</span>&#125;)</div><div class="line">    static void doSomething() &#123;  </div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">unless和only参数对<span class="meta">@After</span>，<span class="meta">@Before</span>以及<span class="meta">@Finally</span>注解都适用。</div></pre></td></tr></table></figure></p>
<p>4.5.2 @After#</p>
<p>使用@After注解的方法会在每个Action调用之后执行：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@After</span></div><div class="line">    static void log() &#123;</div><div class="line">        <span class="type">Logger</span>.info(<span class="string">"Action executed ..."</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static void index() &#123;</div><div class="line">        <span class="type">List</span>&lt;<span class="type">User</span>&gt; users = <span class="type">User</span>.findAll();</div><div class="line">        render(users);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ...</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.5.3 @Catch#</p>
<p>如果有Action方法抛出了异常，那么使用@Catch注解的方法就会执行，且抛出的异常会以参数的形式传递到@Catch注解的方法中。具体实现如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">        </div><div class="line">    <span class="meta">@Catch</span>(IllegalStateException.class)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">logIllegalState</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">        Logger.<span class="keyword">error</span>(<span class="string">"Illegal state %s…"</span>, throwable);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">index</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;User&gt; users = User.findAll();</div><div class="line">        <span class="keyword">if</span> (users.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid database - 0 users"</span>);</div><div class="line">        &#125;</div><div class="line">        render(users);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">使用<span class="meta">@Catch</span>注解和普通的Java异常处理程序一样，捕获父类往往可以获得更多的异常类型。如果拥有多个需要捕获的方法，可以通过指定优先级来确定他们的执行顺序。具体实现如下：</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Catch</span>(value = Throwable.class, priority = <span class="number">1</span>)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">logThrowable</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">        <span class="comment">// Custom error logging…</span></div><div class="line">        Logger.<span class="keyword">error</span>(<span class="string">"EXCEPTION %s"</span>, throwable);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Catch</span>(value = IllegalStateException.class, priority = <span class="number">2</span>)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">logIllegalState</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">        Logger.<span class="keyword">error</span>(<span class="string">"Illegal state %s…"</span>, throwable);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">index</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;User&gt; users = User.findAll();</div><div class="line">        <span class="keyword">if</span>(users.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid database - 0 users"</span>);</div><div class="line">        &#125;</div><div class="line">        render(users);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.5.4 @Finally#</p>
<p>@Finally注解的方法总是在每个Action调用之后执行（无论Action是否成功执行）：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Finally</span></div><div class="line">    static void log() &#123;</div><div class="line">        <span class="type">Logger</span>.info(<span class="string">"Response contains : "</span> + response.out);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static void index() &#123;</div><div class="line">        <span class="type">List</span>&lt;<span class="type">User</span>&gt; users = <span class="type">User</span>.findAll();</div><div class="line">        render(users);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ...</div><div class="line"> </div><div class="line">&#125;</div><div class="line">如果<span class="meta">@Finally</span>注解的方法中包含的参数是可抛出的异常，其方法中的内容还是可以继续执行的，具体如下：</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Finally</span></div><div class="line">    static void log(<span class="type">Throwable</span> e) &#123;</div><div class="line">        <span class="keyword">if</span>( e == <span class="literal">null</span> )&#123;</div><div class="line">            <span class="type">Logger</span>.info(<span class="string">"action call was successful"</span>);</div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">            <span class="type">Logger</span>.info(<span class="string">"action call failed"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static void index() &#123;</div><div class="line">        <span class="type">List</span>&lt;<span class="type">User</span>&gt; users = <span class="type">User</span>.findAll();</div><div class="line">        render(users);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.5.5 使用@with注解增加更多拦截器#</p>
<p>如果某个控制器是其他一些类的父类，那么该控制器中定义的所有拦截器会影响到所有子类。由于Java不允许多重继承，对单纯通过继承来使用拦截器造成了一定的局限性。Play可以通过@With注解，调用其他控制器中已经定义好的拦截方法，从而突破这一局限。比如创建Secure控制器，定义checkAuthenticated()拦截方法验证用户合法性：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Secure</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Before</span></div><div class="line">    static void checkAuthenticated() &#123;</div><div class="line">        <span class="keyword">if</span>(!session.containsKey(<span class="string">"user"</span>)) &#123;</div><div class="line">            unAuthorized();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;    </div><div class="line">在其他的控制器中，可以通过<span class="meta">@With</span>(<span class="type">Secure</span>.<span class="keyword">class</span>)注解将其包含进来：</div><div class="line"></div><div class="line"><span class="meta">@With</span>(<span class="type">Secure</span>.<span class="keyword">class</span>)</div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.6Session和Flash作用域<br> 在Play开发中，如果需要在HTTP请求之间保存数据，可以将数据保存在Session或者Flash内。保存在Session中的数据在整个用户会话中都是有效的，而保存在Flash的数据只对下一次请求有效。</p>
<p>特别需要注意的是，Session和Flash作用域中的数据都是采用Cookie机制添加到随后的HTTP响应中的(并没有存储在服务器上的)，所以数据大小非常有限（不能超过4K），而且只能存储字符串类型的数据。</p>
<p>由于Cookie是使用密钥签名过的，所以客户端不能轻易修改Cookie的数据（否则会失效）。不要将Play的Session当作缓存来使用，如果需要在特定的会话中缓存一些数据，那么可以使用Play内置的缓存机制，并将session.getId()作为缓存的key进行储存。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public <span class="keyword">static</span> <span class="keyword">void</span> index() &#123;</div><div class="line">    <span class="built_in">List</span> messages = Cache.<span class="keyword">get</span>(session.getId() + <span class="string">"-messages"</span>, <span class="built_in">List</span>.<span class="keyword">class</span>);</div><div class="line">    <span class="keyword">if</span>(messages == <span class="keyword">null</span>) &#123;    </div><div class="line">        <span class="comment">// 处理缓存失效</span></div><div class="line">        messages = Message.findByUser(session.<span class="keyword">get</span>(<span class="string">"user"</span>));</div><div class="line">        Cache.<span class="keyword">set</span>(session.getId() + <span class="string">"-messages"</span>, messages, <span class="string">"30mn"</span>);</div><div class="line">    &#125;</div><div class="line">    render(messages);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Session在用户关闭浏览器后就会失效，除非修改配置文件中的application.session.maxAge属性。设置方法如下：</p>
<p>application.session.maxAge=7d  # Remember for one week.<br>使用Play内置的Cache缓存时需要注意，Cache与传统Servlet的HTTP Session对象是不同的。框架无法保证这些缓存对象会一直存在，所以在业务代码中必须处理缓存失效的问题，以便保持应用完全无状态化。</p>
<p>4.7本章小结<br>通过这一章节的学习，我们应该意识到控制器对于Play应用的重要性。控制层基本的工作流程为：接收HTTP请求的参数，通过对域模型的操作来实现业务逻辑，最终调用视图进行渲染。有时候控制器所做的仅仅是简单的查询操作，有时候需要改变域模型的状态（更新数据），或者通过Action链将处理转发至其他控制器方法。值得注意的是，Play将Session数据以Cookie的机制存放在客户端，而服务器端则用Cache的方式进行数据缓存。</p>
</div><div class="tags"><a href="/tags/play/">play</a></div><div class="post-nav"><a href="/2016/11/22/第三章-路由语法/" class="next">第三章 路由语法</a></div><div data-thread-key="2016/11/23/第四章-控制层/" data-title="第四章 控制层" data-url="http://lisxweb.github.io/2016/11/23/第四章-控制层/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/11/23/第四章-控制层/" data-title="第四章 控制层" data-url="http://lisxweb.github.io/2016/11/23/第四章-控制层/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux服务器/">Linux服务器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MAC实用/">MAC实用</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/play-framework框架/">play framework框架</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Linux服务器/" style="font-size: 15px;">Linux服务器</a> <a href="/tags/MAC-Eclipse-快捷键/" style="font-size: 15px;">MAC Eclipse 快捷键</a> <a href="/tags/play/" style="font-size: 15px;">play</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/11/23/第四章-控制层/">第四章 控制层</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/22/第三章-路由语法/">第三章 路由语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/整理MAC下Eclipse的常用快捷键/">整理MAC下Eclipse的常用快捷键</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/Linux服务器增量备份脚步/">Linux服务器增量备份脚本</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/第二章-基础概念/">第二章 基础概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/第一章-绪论/">第一章 绪论</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-commt"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:zhenggchaoo@gmail.com" target="_blank" class="fa fa-email"> </a><a href="http://weibo.com/zhengchaooo" target="_blank" class="fa fa-weibo"></a><a href="https://github.com/chaooo" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">lisxweb</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script>var duoshuoQuery = {short_name:'lisx'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    document.getElementsByTagName('body')[0].appendChild(ds);
})();
</script><script type="text/javascript" src="/js/search.json.js?v=1.0.0"></script></body></html>