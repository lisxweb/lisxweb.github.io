<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人日记 nodejs学习。"><meta name="baidu-site-verification" content="7tp9tihrLG"><title>第三章 路由语法 | 秋过冬漫长天亮中</title><link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.0.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第三章 路由语法</h1><a id="logo" href="/.">秋过冬漫长天亮中</a><p class="description">没有比脚更长的路，走过去，前面是个天！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">第三章 路由语法</h1><div class="post-meta">Nov 22, 2016<span> | </span><span class="category"><a href="/categories/play-framework框架/">play framework框架</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/11/22/第三章-路由语法/" href="/2016/11/22/第三章-路由语法/#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1路由语法"><span class="toc-text">3.1路由语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-HTTP方法"><span class="toc-text">3.1.1 HTTP方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-URI表达式"><span class="toc-text">3.1.2 URI表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-定义Java调用"><span class="toc-text">3.1.3 定义Java调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-404作为Action"><span class="toc-text">3.1.4 404作为Action</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5-指定静态参数"><span class="toc-text">3.1.5 指定静态参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-6-变量和脚本"><span class="toc-text">3.1.6 变量和脚本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2路由优先级"><span class="toc-text">3.2路由优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3提供静态资源"><span class="toc-text">3.3提供静态资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-staticDir-mapping"><span class="toc-text">3.3.1 staticDir:mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-staticFile-mapping"><span class="toc-text">3.3.2 staticFile:mapping</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4虚拟主机"><span class="toc-text">3.4虚拟主机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5逆向生成URL"><span class="toc-text">3.5逆向生成URL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6设置content-type"><span class="toc-text">3.6设置content type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7HTTP内容协商"><span class="toc-text">3.7HTTP内容协商</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-在HTTP头中设置content-type"><span class="toc-text">3.7.1 在HTTP头中设置content type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-自定义格式"><span class="toc-text">3.7.2 自定义格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8关于REST"><span class="toc-text">3.8关于REST</span></a></li></ol></div></div><div class="post-content"><h2 id="3-1路由语法"><a href="#3-1路由语法" class="headerlink" title="3.1路由语法"></a>3.1路由语法</h2><blockquote>
<p>Play路由器使用的配置文件为conf/routes，该文件列出了应用需要的所有路由规则。每条路由由HTTP方法和与Java调用相关联的URI组成。以下是路由配置的例子：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET    /clients/&#123;<span class="built_in">id</span>&#125;     Clients.show</div></pre></td></tr></table></figure></p>
<p>路由配置总是从HTTP方法开始，URI作为中间部分，最后的元素是Java调用。在路由文件中可以使用#进行注释：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Display a client</span></div><div class="line">GET    /clients/&#123;<span class="built_in">id</span>&#125;   Clients.show</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="3-1-1-HTTP方法"><a href="#3-1-1-HTTP方法" class="headerlink" title="3.1.1 HTTP方法"></a>3.1.1 HTTP方法</h3><blockquote>
<p>HTTP协议支持以下所列的方法，用于指定客户请求服务器的动作，其中GET和POST是最为常用的两种方法：</p>
<p>GET<br>POST<br>PUT<br>DELETE<br>HEAD</p>
<p>Play同时也支持以WebSocket的方式来调用服务器端的Action方法，相关内容会在第八章进行详细介绍。</p>
<p>如果在路由文件中指定*作为HTTP方法，那么这个路由会匹配任何HTTP请求：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">*   <span class="regexp">/clients/</span>&#123;id&#125;    Clients.show    </div><div class="line"><span class="comment">#使用上述的路由配置，以下两个HTTP请求都会被框架接受：</span></div><div class="line"></div><div class="line">GET <span class="regexp">/clients/</span><span class="number">1541</span></div><div class="line">PUT <span class="regexp">/clients/</span><span class="number">1212</span></div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="3-1-2-URI表达式"><a href="#3-1-2-URI表达式" class="headerlink" title="3.1.2 URI表达式"></a>3.1.2 URI表达式</h3><blockquote>
<p>URI表达式定义了路由规则需要的请求路径，请求路径中允许存在动态内容，但必须被声明在{}中。</p>
</blockquote>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta-keyword">/clients/</span>all</div><div class="line">以上的路由配置只能精确匹配到：</div><div class="line"><span class="meta-keyword">/clients/</span>all</div><div class="line"></div><div class="line">但是如果以包含动态部分配置路由规则：</div><div class="line"></div><div class="line"><span class="meta-keyword">/clients/</span>&#123;id&#125;</div><div class="line">则可以分别匹配：</div><div class="line"><span class="meta-keyword">/clients/</span><span class="number">12121</span></div><div class="line">和</div><div class="line"><span class="meta-keyword">/clients/</span>toto</div><div class="line"></div><div class="line">如果某条路由配置的URI中需要包含多个动态部分，可以采用下例方法进行配置：</div><div class="line"></div><div class="line"><span class="meta-keyword">/clients/</span>&#123;id&#125;<span class="meta-keyword">/accounts/</span>&#123;accountId&#125;</div><div class="line">默认情况下，动态部分的匹配策略采用的是正则表达式/[^/]+/。也可以为动态部分定义自己的正则表达式，以下是使用正则表达式的例子。</div><div class="line"></div><div class="line">路由规则只允许接受id为数字的值：</div><div class="line"></div><div class="line"><span class="meta-keyword">/clients/</span>&#123;<span class="params">&lt;[<span class="number">0</span><span class="number">-9</span>]+&gt;</span>id&#125;</div><div class="line">路由规则确保id是长度为<span class="number">4</span>到<span class="number">10</span>字符的小写单词：</div><div class="line"></div><div class="line"><span class="meta-keyword">/clients/</span>&#123;<span class="params">&lt;[a-z]&#123;<span class="number">4</span>,<span class="number">10</span>&#125;&gt;</span>id&#125;</div><div class="line">正则表达式的使用非常灵活，还可以定义更多的路由规则，本节就不做赘述了。</div><div class="line"></div><div class="line"></div><div class="line">注意：</div><div class="line">动态部分指定后，控制器可以在HTTP参数map中获取该值。</div><div class="line"></div><div class="line"></div><div class="line">默认情况下，Play将URI尾部的斜线（“/”）作为重要的组成部分，因为有无“/”将会出现不同的结果。比如：</div><div class="line"></div><div class="line">GET     /clients&gt;   Clients.index</div><div class="line">该路由规则会匹配/clients，而不是<span class="meta-keyword">/clinets/</span>（注意这里的区别），但可以通过在斜线后面增加问号来同时匹配两个URI：</div><div class="line"></div><div class="line">GET     <span class="meta-keyword">/clients/</span>?   Clients.index</div></pre></td></tr></table></figure>
<p>注意：<br>URI除了尾斜线不允许有其他可选的部分。</p>
<h3 id="3-1-3-定义Java调用"><a href="#3-1-3-定义Java调用" class="headerlink" title="3.1.3 定义Java调用"></a>3.1.3 定义Java调用</h3><blockquote>
<p>路由定义的最后部分为需要调用的Java方法：控制器中必须定义指定的Action方法，否则会提示找不到控制器方法的错误信息；必须声明为public static void方法；控制器需作为play.mvc.Controller的子类定义在controllers包中。</p>
<p>如果控制器没有在controllers包中定义，在配置路由规则时可以在其名称之前增加Java包（比如admin.Dashboard.index）的说明。由于controllers包本身被Play默认包含，所以用户在配置路由时不需要显式地指定。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET    /admin  admin<span class="selector-class">.Dashboard</span><span class="selector-class">.index</span></div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="3-1-4-404作为Action"><a href="#3-1-4-404作为Action" class="headerlink" title="3.1.4 404作为Action"></a>3.1.4 404作为Action</h3><blockquote>
<p>可以直接使用404作为路由配置中的Action部分。如果这样进行配置，对应的URL路径就会被Play应用所忽略。比如：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#忽略favicon请求</span></div><div class="line"><span class="attribute">GET</span>     /favicon.ico  <span class="number">404</span></div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="3-1-5-指定静态参数"><a href="#3-1-5-指定静态参数" class="headerlink" title="3.1.5 指定静态参数"></a>3.1.5 指定静态参数</h3><blockquote>
<p>在某些情况下，可能会需要基于不同的参数值定义特殊路由。以下是预先定义好的Action：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">page</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">    Page page = Page.findById(id);</div><div class="line">    render(page);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>针对该Action，常规的路由配置为：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET  /pages/&#123;<span class="built_in">id</span>&#125;    Application.page</div></pre></td></tr></table></figure></p>
<p>现在给参数id=home的页面指定一条特殊的URL，需要通过设置静态参数来实现：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GET   /home   Application.page(<span class="string">id:</span><span class="string">'home'</span>)</div><div class="line">GET   <span class="regexp">/pages/</span>&#123;id&#125;   Application.page</div></pre></td></tr></table></figure></p>
<p>当参数id=home时，两条路由配置等价，但是由于前者具有较高的优先级，所以被作为默认的URL来调用Application.page。</p>
</blockquote>
<h3 id="3-1-6-变量和脚本"><a href="#3-1-6-变量和脚本" class="headerlink" title="3.1.6 变量和脚本"></a>3.1.6 变量和脚本</h3><blockquote>
<p>与模板中的使用方法类似，在routes文件中可以使用${…}作为变量表达式，使用%{…}作为脚本表达式，比如：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">%&#123; context = play.configuration.getProperty(<span class="symbol">'context</span>', '') &#125;%</div><div class="line"> </div><div class="line"># 主页</div><div class="line">GET    $&#123;context&#125;&gt;   Secure.login</div><div class="line">GET    $&#123;context&#125;/&gt;  Secure.login</div><div class="line">在路由文件中定义变量和脚本的典型例子是CRUD模块的routes文件。该文件中使用crud.types标签对model类型进行迭代，为每种类型生成控制器路由定义。第十章模块部分会详细介绍CRUD模块的使用。</div><div class="line"></div><div class="line">#&#123;crud.types&#125;</div><div class="line">GET       /?            $&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerClass</span></span>.name.substring(<span class="number">12</span>).replace(<span class="string">'$'</span>,'')&#125;.index</div><div class="line">GET       /$&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerName</span></span>&#125;     $&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerClass</span></span>.name.substring(<span class="number">12</span>).replace(<span class="string">'$'</span>,'')&#125;.list</div><div class="line">GET       /$&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerName</span></span>&#125;/new       $&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerClass</span></span>.name.substring(<span class="number">12</span>).replace(<span class="string">'$'</span>,'')&#125;.blank</div><div class="line">GET       /$&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerName</span></span>&#125;/&#123;id&#125;      $&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerClass</span></span>.name.substring(<span class="number">12</span>).replace(<span class="string">'$'</span>,'')&#125;.show</div><div class="line">GET       /$&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerName</span></span>&#125;/&#123;id&#125;/&#123;field&#125;    $&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerClass</span></span>.name.substring(<span class="number">12</span>).replace(<span class="string">'$'</span>,'')&#125;.attachment</div><div class="line">GET       /$&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerName</span></span>&#125;/&#123;id&#125;/edit       $&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerClass</span></span>.name.substring(<span class="number">12</span>).replace(<span class="string">'$'</span>,'')&#125;.edit</div><div class="line">POST      /$&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerName</span></span>&#125;     $&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerClass</span></span>.name.substring(<span class="number">12</span>).replace(<span class="string">'$'</span>,'')&#125;.create</div><div class="line">POST      /$&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerName</span></span>&#125;/&#123;id&#125;      $&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerClass</span></span>.name.substring(<span class="number">12</span>).replace(<span class="string">'$'</span>,'')&#125;.save</div><div class="line">DELETE    /$&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerName</span></span>&#125;/&#123;id&#125;      $&#123;<span class="class"><span class="keyword">type</span>.<span class="title">controllerClass</span></span>.name.substring(<span class="number">12</span>).replace(<span class="string">'$'</span>,'')&#125;.delete</div><div class="line">#&#123;/crud.types&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="3-2路由优先级"><a href="#3-2路由优先级" class="headerlink" title="3.2路由优先级"></a>3.2路由优先级</h2><p>路由规则定义在conf/routes文件中，当用户向服务器发送请求，框架会解析该文件并选择合适的路由规则，调用相应的Action方法，最终通过HTTP返回数据到客户的浏览器。在实际的项目中，根据路由规则的配置，可能会有多个路由匹配同一请求的情况出现。如果路由存在冲突，Play会按照声明的顺序，优先选择最先声明的路由，比如：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GET     <span class="regexp">/clients/</span>all         Clients.listAll</div><div class="line">GET     <span class="regexp">/clinets/</span>&#123;id&#125;        Clients.show</div></pre></td></tr></table></figure></p>
<blockquote>
<p>在上例的路由配置中，虽然请求/clients/all可以同时匹配这两条路由配置，但按照声明的优先顺序会被第一条路由拦截，并调用相应的Clients.listAll方法。</p>
<p>但实际的项目还会更加复杂些，路由经常需要匹配复杂的字符串规则，这种需求往往令开发者非常头疼。Play路由的动态部分引入正则表达式作为匹配策略，非常轻松地解决了这类问题。在介绍如何使用正则表达式配置Play路由动态部分之前，先介绍一下正则表达式的语法。</p>
<p>正则表达式规定了一些特殊的语法符号，称之为元字符(metacharacter)，元字符的具体语法和说明如表##3.1所示。</p>
</blockquote>
<p>(表##3.1 常用元字符说明)</p>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">匹配除换行符以外的任意字符</td>
<td style="text-align:center">\w</td>
<td style="text-align:center">匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">匹配任意的空白符</td>
<td style="text-align:center">\d</td>
<td style="text-align:center">匹配数字</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">匹配字符串的开始或结束</td>
<td style="text-align:center">^</td>
<td style="text-align:center">匹配字符串的开始</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">匹配字符串的结束</td>
<td style="text-align:center">[…]</td>
<td style="text-align:center">匹配[]中的字符，如[aeiou]就匹配任何一个英文元音字母</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:center">\w的反义，即匹配任意非字母、数字、下划线和汉字的字符</td>
<td style="text-align:center">\S</td>
<td style="text-align:center">\s的反义，即匹配任意非空白符的字符</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:center">\d的反义，即匹配任意非数字的字符</td>
<td style="text-align:center">\B</td>
<td style="text-align:center">\b的反义，即非开头或结束的位置</td>
</tr>
<tr>
<td style="text-align:center">[^…]</td>
<td style="text-align:center">匹配除了…以外的任意字符，如[^abc]匹配除了abc这几个字母之外的任意字符</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>以下路由规则匹配的id参数为一个字母或是数字：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET&gt;    <span class="meta-keyword">/clinets/</span>&#123;<span class="params">&lt;\w&gt;</span>id&#125;         Clients.index</div></pre></td></tr></table></figure></p>
<p>正则表达式还有很多优势，比如能够在模式中包含选择和循环，使用一些重复规则来表达循环匹配，具体语法如表##3.2所示。<br>(表##3.2 正则表达式重复规则)</p>
</blockquote>
<p>重复  说明  重复  说明</p>
<ul>
<li>重复零次或更多次    +   重复一次或更多次<br>?   重复零次或一次 {n} 重复n次<br>{n,}    重复n次或更多次    {n,m}   重复n到m次<blockquote>
<p>如果id参数需要匹配5个数字，在不使用重复规则的前提下，只能连续使用五个\d元字符，而使用重复规则后，规则的如下：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET    <span class="meta-keyword">/clinets/</span>&#123;<span class="params">&lt;\d&#123;<span class="number">5</span>&#125;&gt;</span>id&#125;      Clients.index</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>以下路由规则匹配2个大写字母以及3-4个数字：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET    /clinets/&#123;&lt;[A-Z]&#123;<span class="number">2</span>&#125;[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">3</span>,<span class="number">4</span>&#125;id&#125;&gt; Clients.index</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="3-3提供静态资源"><a href="#3-3提供静态资源" class="headerlink" title="3.3提供静态资源"></a>3.3提供静态资源</h2><h3 id="3-3-1-staticDir-mapping"><a href="#3-3-1-staticDir-mapping" class="headerlink" title="3.3.1 staticDir:mapping"></a>3.3.1 staticDir:mapping</h3><blockquote>
<p>Play的路由配置使用特殊的Action（staticDir）将存放静态资源的public目录开放。该目录里包含的资源可以是图片，Javascript，Stylesheet等，这些资源将直接响应给客户端，并不需要服务器做进一步加工处理：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET    <span class="regexp">/public/</span>     <span class="string">staticDir:</span><span class="keyword">public</span></div></pre></td></tr></table></figure></p>
<p>当客户端请求/public/*路径时，Play会从应用的public文件夹中获取相应的静态资源。这里的优先级与标准路由配置一样适用。</p>
</blockquote>
<h3 id="3-3-2-staticFile-mapping"><a href="#3-3-2-staticFile-mapping" class="headerlink" title="3.3.2 staticFile:mapping"></a>3.3.2 staticFile:mapping</h3><blockquote>
<p>还可以直接将URL路径映射为静态文件：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET     <span class="regexp">/home     staticFile:/</span><span class="keyword">public</span><span class="regexp">/html/i</span>ndex.html</div></pre></td></tr></table></figure></p>
<p>当客户端通过GET方法请求/home时，服务器将不做任何处理直接把/public/html目录下面的index.html文件返回给客户端。</p>
</blockquote>
<h2 id="3-4虚拟主机"><a href="#3-4虚拟主机" class="headerlink" title="3.4虚拟主机"></a>3.4虚拟主机</h2><p>Play的路由器具有主机匹配功能，当Action的变量需要从主机参数（指子域名，而不是子目录）中获取时，就显得特别有用。比如SAAS应用可以使用如下方式配置路由规则：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET    &#123;<span class="keyword">client</span>&#125;.mysoftware.com/   Application.<span class="keyword">index</span></div><div class="line">根据以上配置，框架会自动获取<span class="keyword">client</span>的值作为请求的参数：</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">index</span>(String <span class="keyword">client</span>) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>如果在模板中使用@@{…}标签，那么框架会根据指定的条件来选择对应的路由，这种方式在很多场合下都非常实用。比如，需要在产品中使用额外的服务器来提供静态资源，则可以采用如下方式进行路由配置：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#&#123;if play.Play.mode.isDev()&#125;</span></div><div class="line">    GET     /<span class="keyword">public</span>/                staticDir:<span class="keyword">public</span></div><div class="line"><span class="meta">#&#123;/&#125;</span></div><div class="line"><span class="meta">#&#123;else&#125;</span></div><div class="line">    GET     assets.myapp.com/       staticDir:<span class="keyword">public</span></div><div class="line"><span class="meta">#&#123;/&#125;</span></div></pre></td></tr></table></figure></p>
<p>对应模板中的代码如下：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"@@</span></span></span><span class="template-variable">&#123;'/public/images/logo.png'&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>当应用在DEV模式下运行时，静态资源的URL为<a href="http://locahost:9000/public/images/logo.png；如果运行在PROD模式下，URL为http://assets.myapp.com/images/logo.png。" target="_blank" rel="external">http://locahost:9000/public/images/logo.png；如果运行在PROD模式下，URL为http://assets.myapp.com/images/logo.png。</a></p>
</blockquote>
<h2 id="3-5逆向生成URL"><a href="#3-5逆向生成URL" class="headerlink" title="3.5逆向生成URL"></a>3.5逆向生成URL</h2><p>Play路由器是按照Java调用生成URL的，所以可以将URI表达式都集中到同个配置文件中，使得重构应用变得更加便捷。比如，为conf/routes文件添加如下路由配置：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET    /clients/&#123;id&#125;  Clients.show</div><div class="line">之后在Java代码中，就可以调用<span class="built_in">Client</span>.show来生成URL：</div><div class="line"></div><div class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"id"</span>, <span class="number">1541</span>);</div><div class="line"><span class="keyword">String</span> url = Router.reverse(<span class="string">"Clients.show"</span>, <span class="built_in">map</span>).url;   <span class="comment">//     GET /clients/1541</span></div></pre></td></tr></table></figure></p>
<p>注意：<br>URL的生成已经集成到框架的大部分组件当中，一般我们不需要直接调用Router.reverse方法。</p>
<pre><code>如果增加的参数不包含在URI表达式中，这些参数会被添加到查询字符串中：
</code></pre><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"id"</span>, <span class="number">1541</span>);</div><div class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"display"</span>, <span class="string">"full"</span>);</div><div class="line"><span class="keyword">String</span> url = Router.reverse(<span class="string">"Clients.show"</span>, <span class="built_in">map</span>).url;   <span class="comment">//    GET /clients/1541?display=full</span></div></pre></td></tr></table></figure>
<blockquote>
<p>同样地，路由器会根据优先顺序匹配最适的URL。</p>
<h2 id="3-6设置content-type"><a href="#3-6设置content-type" class="headerlink" title="3.6设置content type"></a>3.6设置content type</h2><p>Play会根据request.format设定的值，选择指定的media类型来响应HTTP请求。该值通过文件扩展名来决定使用何种视图模板进行渲染，并且通过Play框架中的mime-types.properties文件进行映射处理(映射关系详见play\framework\src\play\libs\mime-types.properties文件)，为media类型设定Content-type响应。</p>
<p>Play请求的默认格式为html，因此index()控制器方法默认的渲染模板文件为index.html。如果需要指定其他的格式，有以下四种方式：</p>
</blockquote>
<p>（1）可以在程序代码调用render()方法之前进行格式设置。比如将media类型设置为text/css，就可以使用CSS文件进行渲染：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">()</span> </span>&#123;</div><div class="line">    request.format = <span class="string">"css"</span>; </div><div class="line">    render();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（2）推荐一种更直接的做法，直接在routes文件中使用URL来指定格式。以下列路由配置为例：首先客户端通过index.xml请求服务器，服务器端将响应格式设置为xml，最后使用index.xml模版进行渲染。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET   /<span class="built_in">index</span>.xml    Application.<span class="built_in">index</span>(forma<span class="variable">t:</span><span class="string">'xml'</span>)</div></pre></td></tr></table></figure></p>
<p>同样地，我们也可以使用CSS进行渲染：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET   <span class="regexp">/stylesheets/</span>dynamic_css        css.SiteCSS(<span class="string">format:</span><span class="string">'css'</span>)</div></pre></td></tr></table></figure></p>
<p>(3）Play还可以直接从URL中获取请求格式，动态指定渲染的模板类型。参考如下路由配置：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET   /<span class="built_in">index</span>.&#123;<span class="keyword">format</span>&#125;    Application.<span class="built_in">index</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>当请求为/index.xml时，服务器会将返回格式设置为xml并使用相应的XMl文件进行渲染；请求为/index.txt时，则会使用文本进行渲染。</p>
<p>（4）使用Play中的HTTP内容协商进行格式设置，详见下节内容。</p>
<h2 id="3-7HTTP内容协商"><a href="#3-7HTTP内容协商" class="headerlink" title="3.7HTTP内容协商"></a>3.7HTTP内容协商</h2><p> Play与其他REST架构的框架一样，直接使用HTTP方法，而不是试图隐藏HTTP或者在上面构建抽象层。内容协商是HTTP的特性，它允许HTTP服务器根据客户端的请求类型，实现同个URL提供不同的media类型响应。客户端可以在Accept header中设置media属性，指定可接收的响应类型。如果用户需要XML响应，则进行如下设置：</p>
</blockquote>
<p>Accept:application/xml</p>
<blockquote>
<p>客户端可以指定多种media类型，或使用cacth-all通配符（<em>/</em>）来指定任何media类型。</p>
</blockquote>
<p>Accept:application/xml,image/png,<em>/</em></p>
<blockquote>
<p>常规的Web浏览器总是在Accept header中包含了通配符的值，这样浏览器便会接受任何media类型。Play将HTML作为默认格式进行渲染，因此在客户端使用HTTP内容协商就显得特别有用：通过Ajax请求返回JSON格式，或是使文档以PDF和EPUB形式显示等。</p>
</blockquote>
<h3 id="3-7-1-在HTTP头中设置content-type"><a href="#3-7-1-在HTTP头中设置content-type" class="headerlink" title="3.7.1 在HTTP头中设置content type"></a>3.7.1 在HTTP头中设置content type</h3><blockquote>
<p>如果Accept header中包含了text/html，application/xhtml或者通配符 <em>/</em>，Play会选择使用其默认的请求格式(即HTML)。只有当通配符的值被显式指定时，Play才会选择其默认的请求格式。</p>
<p>Play内置了一些常规格式支持：html、txt、json、xml。下例代码定义了控制器方法(Action)进行数据渲染：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> index() &#123; </div><div class="line">   <span class="keyword">final</span> <span class="keyword">String</span> name = <span class="string">"Peter Hilton"</span>; </div><div class="line">   <span class="keyword">final</span> <span class="keyword">String</span> organisation = <span class="string">"Lunatech Research"</span>; </div><div class="line">   <span class="keyword">final</span> <span class="keyword">String</span> url = <span class="string">"http://www.lunatech-research.com/"</span>; </div><div class="line">   render(name, organisation, url); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果在浏览器中访问<a href="http://localhost:9000，Play默认会使用index.html模板进行渲染，因为浏览器发送了包含text/html的Accept" target="_blank" rel="external">http://localhost:9000，Play默认会使用index.html模板进行渲染，因为浏览器发送了包含text/html的Accept</a> header。</p>
<p>通过将请求的格式设置为xml，可以使用index.xml模板响应标识为Accept: text/xml的请求：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span> </span></div><div class="line"><span class="tag">&lt;<span class="name">contact</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>$<span class="template-variable">&#123;name&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span></div><div class="line"><span class="tag">&lt;<span class="name">organisation</span>&gt;</span>$<span class="template-variable">&#123;organisation&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">organisation</span>&gt;</span> </span></div><div class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>$<span class="template-variable">&#123;url&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span></div><div class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>下表针对index()控制器方法给出了Play内置的Accept header请求格式映射：Accept header包含了Play能够映射成的所有格式（最后转化为相应的模板文件），如表##3.3：</p>
</blockquote>
<p>(表##3.3 Play内置的Accept header请求格式映射)<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Accept header   Format  Template file name  mapping</div><div class="line">null    null    index.html  null格式请求提供默认模版扩展</div><div class="line">image/png   null    index.html  media类型没有映射为指定格式</div><div class="line">*/*, image/png  html    index.html  默认将media类型映射为html格式</div><div class="line">text/html   html    index.html  内置映射</div><div class="line">application/xhtml   html    index.html  内置映射</div><div class="line">text/<span class="keyword">xml</span>    <span class="title">xml</span> index.<span class="keyword">xml</span>   <span class="title">内置映射</span></div><div class="line">application/<span class="keyword">xml</span> <span class="title">xml</span> index.<span class="keyword">xml</span>   <span class="title">内置映射</span></div><div class="line">text/plain  txt index.txt   内置映射</div><div class="line">text/javascript json    index.json  内置映射</div><div class="line">application/json, */*   json    index.json  内置映射, 忽略默认media类型</div></pre></td></tr></table></figure></p>
<h3 id="3-7-2-自定义格式"><a href="#3-7-2-自定义格式" class="headerlink" title="3.7.2 自定义格式"></a>3.7.2 自定义格式</h3><blockquote>
<p>在Play中可以通过检查HTTP请求头，为应用选择相应的media类型来实现自定义格式。比如使用@Before标签拦截该控制器下的所有Action，检查请求的media类型是否为text/x-vcard：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@<span class="function">Before </span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFormat</span>(<span class="params"></span>) &#123; </div><div class="line">    <span class="keyword">if</span> (request.headers.<span class="keyword">get</span>(<span class="string">"accept"</span>).<span class="keyword">value</span>().<span class="keyword">equals</span>(<span class="string">"text/x-vcard"</span>)) &#123; </div><div class="line">&gt;  request.format = <span class="string">"vcf"</span>; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果检查后发现请求头中media类型为text/x-vcard时，将调用index.vcf模板渲染：</p>
</blockquote>
<p>BEGIN:VCARD<br>VERSION:##3.0<br>N:${name}<br>FN:${name}<br>ORG:${organisation}<br>URL:${url}<br>END:VCARD</p>
<h2 id="3-8关于REST"><a href="#3-8关于REST" class="headerlink" title="3.8关于REST"></a>3.8关于REST</h2><p>REST全称为Representational State Transfer，即表述性状态传输。它是一种为分布式超媒体系统（比如万维网）而设计的软件架构方式。REST定义了一些关键的规则：</p>
<p>应用的所有功能都被划分为资源。<br>每个资源都使用URI来唯一访问。<br>所有资源共享统一的接口用于客户端与资源之间进行状态传输。</p>
<blockquote>
<p>如果应用使用的是HTTP协议，那么这些接口是通过一系列可用的HTTP方法来定义的。HTTP协议往往通过以下方法来使用资源的状态：</p>
</blockquote>
<p>客户端-服务器模式。<br>无状态模式。<br>缓存模式。<br>分层模式。</p>
<blockquote>
<p>如果应用遵循了REST设计规则，那么该应用就可以被称为RESTful了。Play框架可以很容易地构建RESTful应用：</p>
</blockquote>
<p>Play的路由器通过解析URI和HTTP方法，将请求路由至Action方法。基于正则表达形式的URI为开发提供了更好的灵活性。<br>协议是无状态的，这意味着在两次成功的请求之间不会把任何状态保存在服务器中。<br>Play将HTTP作为关键的特性，因此框架提供了对HTTP信息的完全访问。</p>
<p>##3.9本章小结<br>  本章着重介绍了Play框架的HTTP特性，对Restful设计风格，路由机制等Play应用开发中的一些关键字做了阐述。Play采用URI与Java方法映射的方式，直接配合HTTP方法来响应用户的请求。而传统的开发框架对HTTP方法做了进一步的抽象，间接性地进行请求处理。值得注意的是，Play的实现并不是基于Servlet的，并且Play集成了基于事件的Netty作为Web服务器，使得应用具备更加高效的性能。本章的最后一节还着重介绍了media类型，以及HTTP内容协商的相关知识，有助于加深读者对Play的HTTP特性的认识。</p>
</div><div class="tags"><a href="/tags/play/">play</a></div><div class="post-nav"><a href="/2016/11/21/整理MAC下Eclipse的常用快捷键/" class="next">整理MAC下Eclipse的常用快捷键</a></div><div data-thread-key="2016/11/22/第三章-路由语法/" data-title="第三章 路由语法" data-url="http://lisxweb.github.io/2016/11/22/第三章-路由语法/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/11/22/第三章-路由语法/" data-title="第三章 路由语法" data-url="http://lisxweb.github.io/2016/11/22/第三章-路由语法/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux服务器/">Linux服务器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MAC实用/">MAC实用</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/play-framework框架/">play framework框架</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/MAC-Eclipse-快捷键/" style="font-size: 15px;">MAC Eclipse 快捷键</a> <a href="/tags/play/" style="font-size: 15px;">play</a> <a href="/tags/Linux服务器/" style="font-size: 15px;">Linux服务器</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/11/22/第三章-路由语法/">第三章 路由语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/整理MAC下Eclipse的常用快捷键/">整理MAC下Eclipse的常用快捷键</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/Linux服务器增量备份脚步/">Linux服务器增量备份脚本</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/第二章-基础概念/">第二章 基础概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/第一章-绪论/">第一章 绪论</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-commt"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:zhenggchaoo@gmail.com" target="_blank" class="fa fa-email"> </a><a href="http://weibo.com/zhengchaooo" target="_blank" class="fa fa-weibo"></a><a href="https://github.com/chaooo" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">lisxweb</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script>var duoshuoQuery = {short_name:'lisx'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    document.getElementsByTagName('body')[0].appendChild(ds);
})();
</script><script type="text/javascript" src="/js/search.json.js?v=1.0.0"></script></body></html>